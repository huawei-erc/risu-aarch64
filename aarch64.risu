###############################################################################
# Copyright (c) 2010 Linaro Limited
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the Eclipse Public License v1.0
# which accompanies this distribution, and is available at
# http://www.eclipse.org/legal/epl-v10.html
#
# Contributors:
#     Claudio Fontana - initial implementation
#     based on arm.risu by Peter Maydell
###############################################################################

# Input file for risugen defining AArch64 instructions
.mode aarch64

# from ARM DDI 0487A.a ARM Architecture Reference Manual
# XXX NIY: branch, exception generation, system insns
# XXX NIY: PC-related instructions
# XXX NIY: SP-related instructions
# XXX NIY: floating point and SIMD specific insns

# - - - - 1 - 0 - - - - - - - - - - - - - - - Loads and stores
# C3.3 Loads and stores

# C3.3.1 AdvSIMD load/store multiple structures
# C3.3.2 AdvSIMD load/store multiple structures (post-indexed)
# C3.3.3 AdvSIMD load/store single structure
# C3.3.4 AdvSIMD load/store single structure (post-indexed)
#
# C6.3.275 ST1 (multiple structures) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  0  0  0  0  0  0  0  0  x  x  1  x size   Rn   Rt
#                            [L]                  [  opcode  ]

ST1m_1 A64_V 0 Q:1 001100000 00000 0111 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1 << $size); reg($rn); }

ST1m_2 A64_V 0 Q:1 001100000 00000 1010 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1 << $size); reg($rn); }

ST1m_3 A64_V 0 Q:1 001100000 00000 0110 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1 << $size); reg($rn); }

ST1m_4 A64_V 0 Q:1 001100000 00000 0010 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1 << $size); reg($rn); }

# Post-index (reg/immediate)
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  1  0  0    Rm     x  x  1  x  size  Rn   Rt
#                            [L]            [  opcode  ]

ST1m_1p A64_V 0 Q:1 001100100 rm:5 0111 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1 << $size); reg($rn); }

ST1m_2p A64_V 0 Q:1 001100100 rm:5 1010 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1 << $size); reg($rn); }

ST1m_3p A64_V 0 Q:1 001100100 rm:5 0110 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1 << $size); reg($rn); }

ST1m_4p A64_V 0 Q:1 001100100 rm:5 0010 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1 << $size); reg($rn); }

# C6.3.276 ST1 (single structure) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  0  0  0  0  0  0  0  0  x  x  0  S  size  Rn   Rt
#                            [L][R]               [  opc  ]
#              8-bit variant (opcode = 000)
#    ST1 { <Vt>.B }[<index>], [<Xn|SP>]
#              16-bit variant (opcode = 010, size = x0)
#    ST1 { <Vt>.H }[<index>], [<Xn|SP>]
#              32-bit variant (opcode = 100, size = 00)
#    ST1 { <Vt>.S }[<index>], [<Xn|SP>]
#              64-bit variant (opcode = 100, S = 0, size = 01)
#    ST1 { <Vt>.D }[<index>], [<Xn|SP>]

ST1_B A64_V 0 Q:1 001101000 00000 000 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1); reg($rn); }

ST1_H A64_V 0 Q:1 001101000 00000 010 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && !($size & 0x01); } \
!memory { align(2); reg($rn); }

# ReservedValue: break !(size & 0x01) constraint
ST1_H_RES A64_V 0 Q:1 001101000 00000 010 S:1 size:1 1 rn:5 rt:5

ST1_S A64_V 0 Q:1 001101000 00000 100 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(4); reg($rn); }

ST1_D A64_V 0 Q:1 001101000 00000 100 0 01 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(8); reg($rn); }

# Post-index (reg/immediate)
#  31 30 29 28 27 26 25 24 23 22 21 20    16 15 14 13 12 11 10 9  5 4  0
#   0  Q  0  0  1  1  0  1  1  0  0    Rm     x  x  0  S size   Rn   Rt
#                             [L][R]          opcode

ST1_Bp A64_V 0 Q:1 001101100 rm:5 000 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1); reg($rn); }

ST1_Hp A64_V 0 Q:1 001101100 rm:5 010 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm && !($size & 0x01); } \
!memory { align(2); reg($rn); }

# ReservedValue: break (!size & 0x01) constraint
ST1_Hp_RES A64_V 0 Q:1 001101100 rm:5 010 S:1 size:1 1 rn:5 rt:5

ST1_Sp A64_V 0 Q:1 001101100 rm:5 100 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(4); reg($rn); }

ST1_Dp A64_V 0 Q:1 001101100 rm:5 100 0 01 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(8); reg($rn); }

# C6.3.277 ST2 (multiple structures) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  0  0  0  0  0  0  0  0  1  0  0  0  size  Rn   Rt
#                            [L]                  [  opcode  ]

ST2m A64_V 0 Q:1 001100000 00000 1000 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && !($size == 3 && $Q == 0); } \
!memory { align(1 << $size); reg($rn); }

# ReservedValue: break the !($size == 3 && $Q == 0) constraint
ST2m_RES A64_V 0 0 001100000 00000 1000 11 rn:5 rt:5

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20          16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  1  0  0       Rm        1  0  0  0  size  Rn   Rt
#                            [L]                  [  opcode  ]

ST2m_p A64_V 0 Q:1 001100100 rm:5 1000 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm && !($size == 3 && $Q == 0); } \
!memory { align(1 << $size); reg($rn); }

# ReservedValue: break the !($size == 3 && $Q == 0) constraint
ST2m_p_RES A64_V 0 0 001100100 rm:5 1000 11 rn:5 rt:5

# C6.3.278 ST2 (single structure) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  0  0  1  0  0  0  0  0  x  x  0  S  size  Rn   Rt
#                            [L][R]               [  opc  ]

ST2_B A64_V 0 Q:1 001101001 00000 000 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1); reg($rn); }

ST2_H A64_V 0 Q:1 001101001 00000 010 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && !($size & 0x01); } \
!memory { align(2); reg($rn); }

# ReservedValue: break the !($size & 0x01) constraint
ST2_H_RES A64_V 0 Q:1 001101001 00000 010 S:1 size:1 1 rn:5 rt:5

ST2_S A64_V 0 Q:1 001101001 00000 100 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(4); reg($rn); }

ST2_D A64_V 0 Q:1 001101001 00000 100 0 01 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(8); reg($rn); }

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  1  0  1    Rm     x  x  0  S  size  Rn   Rt
#                            [L][R]         [  opc  ]

ST2_Bp A64_V 0 Q:1 001101101 rm:5 000 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1); reg($rn); }

ST2_Hp A64_V 0 Q:1 001101101 rm:5 010 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm && !($size & 0x01); } \
!memory { align(2); reg($rn); }

# ReservedValue: break the !($size & 0x01) constraint
ST2_Hp_RES A64_V 0 Q:1 001101101 rm:5 010 S:1 size:1 1 rn:5 rt:5

ST2_Sp A64_V 0 Q:1 001101101 rm:5 100 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(4); reg($rn); }

ST2_Dp A64_V 0 Q:1 001101101 rm:5 100 0 01 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(8); reg($rn); }

# C6.3.279 ST3 (multiple structures) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  0  0  0  0  0  0  0  0  0  1  0  0  size  Rn   Rt
#                            [L]                  [  opcode  ]
ST3m A64_V 0 Q:1 001100000 00000 0100 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && !($size == 3 && $Q == 0); } \
!memory { align(1 << $size); reg($rn); }

# ReservedValue: break the !($size == 3 && $Q == 0) constraint
ST3m_RES A64_V 0 0 001100000 00000 0100 11 rn:5 rt:5

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20          16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  1  0  0       Rm        0  1  0  0  size  Rn   Rt
#                            [L]                  [  opcode  ]

ST3m_p A64_V 0 Q:1 001100100 rm:5 0100 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rm != $rn && !($size == 3 && $Q == 0); } \
!memory { align(1 << $size); reg($rn); }

# ReservedValue: break the !($size == 3 && $Q == 0) constraint
ST3m_p_RES A64_V 0 0 001100100 rm:5 0100 11 rn:5 rt:5

# C6.3.280 ST3 (single structure) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  0  0  0  0  0  0  0  0  x  x  1  S  size  Rn   Rt
#                            [L][R]               [  opc  ]

ST3_B A64_V 0 Q:1 001101000 00000 001 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1); reg($rn); }

ST3_H A64_V 0 Q:1 001101000 00000 011 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && !($size & 0x01); } \
!memory { align(2); reg($rn); }

# ReservedValue: break the !($size & 0x01) constraint
ST3_H_RES A64_V 0 Q:1 001101000 00000 011 S:1 size:1 1 rn:5 rt:5

ST3_S A64_V 0 Q:1 001101000 00000 101 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(4); reg($rn); }

ST3_D A64_V 0 Q:1 001101000 00000 101 0 01 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(8); reg($rn); }

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  1  0  0    Rm     x  x  1  S  size  Rn   Rt
#                            [L][R]         [  opc  ]

ST3_Bp A64_V 0 Q:1 001101100 rm:5 001 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1); reg($rn); }

ST3_Hp A64_V 0 Q:1 001101100 rm:5 011 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm && !($size & 0x01); } \
!memory { align(2); reg($rn); }

# ReservedValue: break the !($size & 0x01) constraint
ST3_Hp_RES A64_V 0 Q:1 001101100 rm:5 011 S:1 size:1 1 rn:5 rt:5

ST3_Sp A64_V 0 Q:1 001101100 rm:5 101 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(4); reg($rn); }

ST3_Dp A64_V 0 Q:1 001101100 rm:5 101 0 01 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(8); reg($rn); }

# C6.3.281 ST4 (multiple structures) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  size  Rn   Rt
#                            [L]                  [  opcode  ]

ST4m A64_V 0 Q:1 001100000 00000 0000 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && !($size == 3 && $Q == 0); } \
!memory { align(1 << $size); reg($rn); }

# ReservedValue: break the !($size == 3 && $Q == 0) constraint
ST4m_RES A64_V 0 0 001100000 00000 0000 11 rn:5 rt:5

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20  16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  1  0  0   Rm    0  0  0  0  size  Rn   Rt
#                            [L]          [  opcode  ]

ST4m_p A64_V 0 Q:1 001100100 rm:5 0000 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rm != $rn && !($size == 3 && $Q == 0); } \
!memory { align(1 << $size); reg($rn); }

# ReservedValue: break the !($size == 3 && $Q == 0) constraint
ST4m_p_RES A64_V 0 0 001100100 rm:5 0000 11 rn:5 rt:5

# C6.3.282 ST4 (single structure) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  0  0  1  0  0  0  0  0  x  x  1  S  size  Rn   Rt
#                            [L][R]               [  opc  ]

ST4_B A64_V 0 Q:1 001101001 00000 001 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1); reg($rn); }

ST4_H A64_V 0 Q:1 001101001 00000 011 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && !($size & 0x01); } \
!memory { align(2); reg($rn); }

# ReservedValue: break the !($size & 0x01) constraint
ST4_H_RES A64_V 0 Q:1 001101001 00000 011 S:1 size:1 1 rn:5 rt:5

ST4_S A64_V 0 Q:1 001101001 00000 101 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(4); reg($rn); }

ST4_D A64_V 0 Q:1 001101001 00000 101 0 01 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(8); reg($rn); }

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  1  0  1    Rm     x  x  1  S  size  Rn   Rt
#                            [L][R]         [  opc  ]

ST4_Bp A64_V 0 Q:1 001101101 rm:5 001 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1); reg($rn); }

ST4_Hp A64_V 0 Q:1 001101101 rm:5 011 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm && !($size & 0x01); } \
!memory { align(2); reg($rn); }

# ReservedValue: break the !($size & 0x01) constraint
ST4_Hp_RES A64_V 0 Q:1 001101101 rm:5 011 S:1 size:1 1 rn:5 rt:5

ST4_Sp A64_V 0 Q:1 001101101 rm:5 101 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(4); reg($rn); }

ST4_Dp A64_V 0 Q:1 001101101 rm:5 101 0 01 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(8); reg($rn); }


# C6.3.152 LD1 (multiple structures) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  0  1  0  0  0  0  0  0  x  x  1  x  size  Rn   Rt
#                            [L]                  [  opcode  ]

LD1m_1 A64_V 0 Q:1 001100010 00000 0111 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1 << $size); reg($rn); }

LD1m_2 A64_V 0 Q:1 001100010 00000 1010 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1 << $size); reg($rn); }

LD1m_3 A64_V 0 Q:1 001100010 00000 0110 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1 << $size); reg($rn); }

LD1m_4 A64_V 0 Q:1 001100010 00000 0010 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1 << $size); reg($rn); }

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  1  1  0    Rm     x  x  1  x  size  Rn   Rt
#                            [L]            [  opcode  ]

LD1m_1p A64_V 0 Q:1 001100110 rm:5 0111 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1 << $size); reg($rn); }

LD1m_2p A64_V 0 Q:1 001100110 rm:5 1010 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1 << $size); reg($rn); }

LD1m_3p A64_V 0 Q:1 001100110 rm:5 0110 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1 << $size); reg($rn); }

LD1m_4p A64_V 0 Q:1 001100110 rm:5 0010 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1 << $size); reg($rn); }

# C6.3.153 LD1 (single structure) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  0  1  0  0  0  0  0  0  x  x  0  S  size  Rn   Rt
#                            [L][R]               [  opc  ]

LD1_B A64_V 0 Q:1 001101010 00000 000 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1); reg($rn); }

LD1_H A64_V 0 Q:1 001101010 00000 010 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && !($size & 0x01); } \
!memory { align(2); reg($rn); }

# ReservedValue: break the !($size & 0x01) constraint
LD1_H_RES A64_V 0 Q:1 001101010 00000 010 S:1 size:1 1 rn:5 rt:5

LD1_S A64_V 0 Q:1 001101010 00000 100 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(4); reg($rn); }

LD1_D A64_V 0 Q:1 001101010 00000 100 0 01 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(8); reg($rn); }

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  1  1  0    Rm     x  x  0  S  size  Rn   Rt
#                            [L][R]         [  opc  ]

LD1_Bp A64_V 0 Q:1 001101110 rm:5 000 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1); reg($rn); }

LD1_Hp A64_V 0 Q:1 001101110 rm:5 010 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm && !($size & 0x01); } \
!memory { align(2); reg($rn); }

# ReservedValue: break the !($size & 0x01) constraint
LD1_Hp_RES A64_V 0 Q:1 001101110 rm:5 010 S:1 size:1 1 rn:5 rt:5

LD1_Sp A64_V 0 Q:1 001101110 rm:5 100 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(4); reg($rn); }

LD1_Dp A64_V 0 Q:1 001101110 rm:5 100 0 01 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(8); reg($rn); }


# C6.3.154 LD1R - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  0  1  0  0  0  0  0  0  1  1  0  0  size  Rn   Rt
#                            [L][R]               [  opc  ][S]

LD1R A64_V 0 Q:1 001101010 00000 110 0 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1 << $size); reg($rn); }

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20  16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  1  1  0   Rm    1  1  0  0  size  Rn   Rt
#                            [L][R]       [  opc  ][S]

LD1R_p A64_V 0 Q:1 001101110 rm:5 110 0 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1 << $size); reg($rn); }

# C6.3.155 LD2 (multiple structures) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  0  1  0  0  0  0  0  0  1  0  0  0  size  Rn   Rt
#                            [L]                  [  opcode  ]

LD2m A64_V 0 Q:1 001100010 00000 1000 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && !($size == 3 && $Q == 0); } \
!memory { align(1 << $size); reg($rn); }

# ReservedValue: break the !($size == 3 && $Q == 0) constraint
LD2m_RES A64_V 0 0 001100010 00000 1000 11 rn:5 rt:5

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20  16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  1  1  0   Rm    1  0  0  0  size  Rn   Rt
#                            [L]          [  opcode  ]

LD2m_p A64_V 0 Q:1 001100110 rm:5 1000 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm && !($size == 3 && $Q == 0); } \
!memory { align(1 << $size); reg($rn); }

# ReservedValue: break the !($size == 3 && $Q == 0) constraint
LD2m_p_RES A64_V 0 0 001100110 rm:5 1000 11 rn:5 rt:5

# C6.3.156 LD2 (single structure) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  0  1  1  0  0  0  0  0  x  x  0  S  size  Rn   Rt
#                            [L][R]               [  opc  ]

LD2_B A64_V 0 Q:1 001101011 00000 000 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1); reg($rn); }

LD2_H A64_V 0 Q:1 001101011 00000 010 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && !($size & 0x01); } \
!memory { align(2); reg($rn); }

# ReservedValue: break the !($size & 0x01) constraint
LD2_H_RES A64_V 0 Q:1 001101011 00000 010 S:1 size:1 1 rn:5 rt:5

LD2_S A64_V 0 Q:1 001101011 00000 100 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(4); reg($rn); }

LD2_D A64_V 0 Q:1 001101011 00000 100 0 01 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(8); reg($rn); }

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20  16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  1  1  1   Rm    x  x  0  S  size  Rn   Rt
#                            [L][R]       [  opc  ]

LD2_Bp A64_V 0 Q:1 001101111 rm:5 000 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1); reg($rn); }

LD2_Hp A64_V 0 Q:1 001101111 rm:5 010 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm && !($size & 0x01); } \
!memory { align(2); reg($rn); }

# ReservedValue: break the !($size & 0x01) constraint
LD2_Hp_RES A64_V 0 Q:1 001101111 rm:5 010 S:1 size:1 1 rn:5 rt:5

LD2_Sp A64_V 0 Q:1 001101111 rm:5 100 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(4); reg($rn); }

LD2_Dp A64_V 0 Q:1 001101111 rm:5 100 0 01 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(8); reg($rn); }

# C6.3.157 LD2R - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  0  1  1  0  0  0  0  0  1  1  0  0  size  Rn   Rt
#                            [L][R]               [  opc  ] S

LD2R A64_V 0 Q:1 001101011 00000 110 0 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1 << $size); reg($rn); }

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  1  1  1    Rm     1  1  0  0  size  Rn   Rt
#                            [L][R]         [  opc  ] S

LD2R_p A64_V 0 Q:1 001101111 rm:5 110 0 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1 << $size); reg($rn); }

# C6.3.158 LD3 (multiple structures) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  0  1  0  0  0  0  0  0  0  1  0  0  size  Rn   Rt
#                            [L]                  [  opcode  ]

LD3m A64_V 0 Q:1 001100010 00000 0100 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && !($size == 3 && $Q == 0); } \
!memory { align(1 << $size); reg($rn); }

# ReservedValue: break the !($size == 3 && $Q == 0) constraint
LD3m_RES A64_V 0 0 001100010 00000 0100 11 rn:5 rt:5

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  1  1  0    Rm     0  1  0  0  size  Rn   Rt
#                            [L]            [  opcode  ]

LD3m_p A64_V 0 Q:1 001100110 rm:5 0100 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm && !($size == 3 && $Q == 0); } \
!memory { align(1 << $size); reg($rn); }

# ReservedValue: break the !($size == 3 && $Q == 0) constraint
LD3m_p_RES A64_V 0 0 001100110 rm:5 0100 11 rn:5 rt:5

# C6.3.159 LD3 (single structure) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  0  1  0  0  0  0  0  0  x  x  1  S  size  Rn   Rt
#                            [L][R]               [  opc  ]

LD3_B A64_V 0 Q:1 001101010 00000 001 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1); reg($rn); }

LD3_H A64_V 0 Q:1 001101010 00000 011 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && !($size & 0x01); } \
!memory { align(2); reg($rn); }

# ReservedValue: break the !($size & 0x01) constraint
LD3_H_RES A64_V 0 Q:1 001101010 00000 011 S:1 size:1 1 rn:5 rt:5

LD3_S A64_V 0 Q:1 001101010 00000 101 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(4); reg($rn); }

LD3_D A64_V 0 Q:1 001101010 00000 101 0 01 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(8); reg($rn); }

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  1  1  0    Rm     x  x  1  S  size  Rn   Rt
#                            [L][R]         [  opc  ]

LD3_Bp A64_V 0 Q:1 001101110 rm:5 001 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1); reg($rn); }

LD3_Hp A64_V 0 Q:1 001101110 rm:5 011 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm && !($size & 0x01); } \
!memory { align(2); reg($rn); }

LD3_Hp_RES A64_V 0 Q:1 001101110 rm:5 011 S:1 size:1 1 rn:5 rt:5

LD3_Sp A64_V 0 Q:1 001101110 rm:5 101 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(4); reg($rn); }

LD3_Dp A64_V 0 Q:1 001101110 rm:5 101 0 01 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(8); reg($rn); }

# C6.3.160 LD3R - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  0  1  0  0  0  0  0  0  1  1  1  0  size  Rn   Rt
#                            [L][R]               [  opc  ] S

LD3R A64_V 0 Q:1 001101010 00000 111 0 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1 << $size); reg($rn); }

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  1  1  0    Rm     1  1  1  0  size  Rn   Rt
#                            [L][R]         [  opc  ] S

LD3R_p A64_V 0 Q:1 001101110 rm:5 111 0 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1 << $size); reg($rn); }

# C6.3.161 LD4 (multiple structures) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  0  1  0  0  0  0  0  0  0  0  0  0  size  Rn   Rt
#                            [L]                  [  opcode  ]

LD4m A64_V 0 Q:1 001100010 00000 0000 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && !($size == 3 && $Q == 0); } \
!memory { align(1 << $size); reg($rn); }

# ReservedValue: break the !($size == 3 && $Q == 0) constraint
LD4m_RES A64_V 0 0 001100010 00000 0000 11 rn:5 rt:5

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  1  1  0    Rm     0  0  0  0  size  Rn   Rt
#                            [L]            [  opcode  ]

LD4m_p A64_V 0 Q:1 001100110 rm:5 0000 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm && !($size == 3 && $Q == 0); } \
!memory { align(1 << $size); reg($rn); }

# ReservedValue: break the !($size == 3 && $Q == 0) constraint
LD4m_p_RES A64_V 0 0 001100110 rm:5 0000 11 rn:5 rt:5

# C6.3.162 LD4 (single structure) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  0  1  1  0  0  0  0  0  x  x  1  S  size  Rn   Rt
#                            [L][R]               [  opc  ]

LD4_B A64_V 0 Q:1 001101011 00000 001 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1); reg($rn); }

LD4_H A64_V 0 Q:1 001101011 00000 011 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && !($size & 0x01); } \
!memory { align(2); reg($rn); }

# ReservedValue: break the !($size & 0x01) constraint
LD4_H_RES A64_V 0 Q:1 001101011 00000 011 S:1 size:1 1 rn:5 rt:5

LD4_S A64_V 0 Q:1 001101011 00000 101 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(4); reg($rn); }

LD4_D A64_V 0 Q:1 001101011 00000 101 0 01 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(8); reg($rn); }

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  1  1  1    Rm     x  x  1  S  size  Rn   Rt
#                            [L][R]         [  opc  ]

LD4_Bp A64_V 0 Q:1 001101111 rm:5 001 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1); reg($rn); }

LD4_Hp A64_V 0 Q:1 001101111 rm:5 011 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm && !($size & 0x01); } \
!memory { align(2); reg($rn); }

# ReservedValue: break the !($size & 0x01) constraint
LD4_Hp_RES A64_V 0 Q:1 001101111 rm:5 011 S:1 size:1 1 rn:5 rt:5

LD4_Sp A64_V 0 Q:1 001101111 rm:5 101 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(4); reg($rn); }

LD4_Dp A64_V 0 Q:1 001101111 rm:5 101 0 01 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(8); reg($rn); }

# C6.3.163 LD4R - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  0  1  1  0  0  0  0  0  1  1  1  0  size  Rn   Rt
#                            [L][R]               [  opc  ] S

LD4R A64_V 0 Q:1 001101011 00000 111 0 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1 << $size); reg($rn); }

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  1  1  1    Rm     1  1  1  0  size  Rn   Rt
#                            [L][R]         [  opc  ] S

LD4R_p A64_V 0 Q:1 001101111 rm:5 111 0 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1 << $size); reg($rn); }

# C3.3.5 Load register (PC-relative literal)
# 31 30 29 28 27 26 25 24 23       5 4    0
#  opc   0  1  1  V  0  0    imm19     Rt
#
# XXX claudio NIY: problematic, as we need to reach the memblock
# as a PC-relative immediate offset, and check the
# constraints (whether it fits in immx).
#
# LDR_L A64 opc:2 0110 00 imm:19 rt:5 \
# !constraints { $opc != 0x3; } \
# !memory { pc_adr(); }
# PRFM_L A64 11 0 110 00 imm:19 rt:5

# C3.3.6 Load/store exclusive
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15 14     10 9    5 4    0
#  size  0  0  1  0  0  0 o2  L o1    Rs    o0    Rt2      Rn     Rt

# size o2 L o1 o0
#  00   0  0 0  0  STXRB            -
#  00   0  0 0  1  STLXRB           -
#  00   1  0 0  1  STLRB            -

#  01   0  0 0  0  STXRH            -
#  01   0  0 0  1  STLXRH           -
#  01   1  0 0  1  STLRH            -

#  00   0  1 0  0  LDXRB            -
#  00   0  1 0  1  LDAXRB           -
#  00   1  1 0  1  LDARB            -

#  01   0  1 0  0  LDXRH            -
#  01   0  1 0  1  LDAXRH           -
#  01   1  1 0  1  LDARH            -

#  10   0  0 0  0  STXR        32-bit
#  10   0  0 0  1  STLXR       32-bit
#  10   1  0 0  1  STLR        32-bit

#  10   0  1 0  0  LDXR        32-bit
#  10   0  1 0  1  LDAXR       32-bit
#  10   1  1 0  1  LDAR        32-bit

#  11   0  0 0  0  STXR        64-bit
#  11   0  0 0  1  STLXR       64-bit
#  11   1  0 0  1  STLR        64-bit

#  11   0  1 0  0  LDXR        64-bit
#  11   0  1 0  1  LDAXR       64-bit
#  11   1  1 0  1  LDAR        64-bit

# data is in rt, base address in rn, status written to rs

# XXX note: the rn != rt, rn != rtt constraint is a limitation
# of risu. If rn = rt, the SUB used to normalize the base to a non
# process-dependent value is going to have the opposite effect to
# change the load result to a process-dependent value.
# The Tech. Ref. Manual defines behavior for rn == rt in some
# cases (not with writeback, ... etc), so at some point we should
# find out how to relax some of these constraints to really check
# the whole range of possibilities.

STXRB A64 00 001000 000 rs:5 0 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rn && $rn != $rt; } \
!memory { align(1); reg($rn); }

STLXRB A64 00 001000 000 rs:5 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rn && $rn != $rt; } \
!memory { align(1); reg($rn); }

STLRB A64 00 001000 100 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(1); reg($rn); }

STXRH A64 01 001000 000 rs:5 0 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rn && $rn != $rt; } \
!memory { align(2); reg($rn); }

STLXRH A64 01 001000 000 rs:5 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rn && $rn != $rt; } \
!memory { align(2); reg($rn); }

STLRH A64 01 001000 100 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(2); reg($rn); }

LDXRB A64 00 001000 010 11111 0 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(1); reg($rn); }

LDAXRB A64 00 001000 010 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(1); reg($rn); }

LDARB A64 00 001000 110 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(1); reg($rn); }

LDXRH A64 01 001000 010 11111 0 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(2); reg($rn); }

LDAXRH A64 01 001000 010 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(2); reg($rn); }

LDARH A64 01 001000 110 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(2); reg($rn); }

STXRW A64 10 001000 000 rs:5 0 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rn && $rn != $rt; } \
!memory { align(4); reg($rn); }

STLXRW A64 10 001000 000 rs:5 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rn && $rn != $rt; } \
!memory { align(4); reg($rn); }

STLRW A64 10 001000 100 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(4); reg($rn); }

LDXRW A64 10 001000 010 11111 0 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(4); reg($rn); }

LDAXRW A64 10 001000 010 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(4); reg($rn); }

LDARW A64 10 001000 110 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(4); reg($rn); }

STXR A64 11 001000 000 rs:5 0 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rn && $rn != $rt; } \
!memory { align(8); reg($rn); }

STLXR A64 11 001000 000 rs:5 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rn && $rn != $rt; } \
!memory { align(8); reg($rn); }

STLR A64 11 001000 100 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(8); reg($rn); }

LDXR A64 11 001000 010 11111 0 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(8); reg($rn); }

LDAXR A64 11 001000 010 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(8); reg($rn); }

LDAR A64 11 001000 110 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(8); reg($rn); }

#  Now with P (pair load/stores):
#  10   0  0 1  0  STXP        32-bit
#  10   0  0 1  1  STLXP       32-bit

#  10   0  1 1  0  LDXP        32-bit
#  10   0  1 1  1  LDAXP       32-bit

#  11   0  0 1  0  STXP        64-bit
#  11   0  0 1  1  STLXP       64-bit

#  11   0  1 1  0  LDXP        64-bit
#  11   0  1 1  1  LDAXP       64-bit

STXPW A64 10 001000 001 rs:5 0 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rtt && $rs != $rn && $rn != $rt && $rn != $rtt; } \
!memory { align(8); reg($rn); }

STLXPW A64 10 001000 001 rs:5 1 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rtt && $rs != $rn && $rn != $rt && $rn != $rtt; } \
!memory { align(8); reg($rn); }

LDXPW A64 10 001000 011 11111 0 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt && $rn != $rt && $rn != $rtt; } \
!memory { align(8); reg($rn); }

LDAXPW A64 10 001000 011 11111 1 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt && $rn != $rt && $rn != $rtt; } \
!memory { align(8); reg($rn); }

STXP A64 11 001000 001 rs:5 0 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rtt && $rs != $rn && $rn != $rt && $rn != $rtt; } \
!memory { align(16); reg($rn); }

STLXP A64 11 001000 001 rs:5 1 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rtt && $rs != $rn && $rn != $rt && $rn != $rtt; } \
!memory { align(16); reg($rn); }

LDXP A64 11 001000 011 11111 0 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt && $rn != $rt && $rn != $rtt; } \
!memory { align(16); reg($rn); }

LDAXP A64 11 001000 011 11111 1 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt && $rn != $rt && $rn != $rtt; } \
!memory { align(16); reg($rn); }

# C3.3.7 Load/store no-allocate pair (offset)
# 31 30 29 28 27 26 25 24 23 22 21      15 14     10 9    5 4    0
#  opc   1  0  1  V  0  0  0  L    simm7      Rt2      Rn     Rt
#
#  opc            V           L
#   00            0           0    STNP 32-bit
#   00            0           1    LDNP 32-bit
#   10            0           0    STNP 64-bit
#   10            0           1    LDNP 64-bit

STNPW A64 00 101 0 000 0 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rn != $rtt; } \
!memory { align(8); reg_plus_imm($rn, sextract($imm, 7) * 4); }

LDNPW A64 00 101 0 000 1 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt && $rn != $rt && $rn != $rtt; } \
!memory { align(8); reg_plus_imm($rn, sextract($imm, 7) * 4); }

STNP A64 10 101 0 000 0 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rn != $rtt; } \
!memory { align(16); reg_plus_imm($rn, sextract($imm, 7) * 8); }

LDNP A64 10 101 0 000 1 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt && $rn != $rt && $rn != $rtt; } \
!memory { align(16); reg_plus_imm($rn, sextract($imm, 7) * 8); }

# SIMD variants
#  opc            V           L
#   00            1           0    SIMD STNP  32-bit
#   00            1           1    SIMD LDNP  32-bit
#   01            1           0    SIMD STNP  64-bit
#   01            1           1    SIMD LDNP  64-bit
#   10            1           0    SIMD STNP 128-bit
#   10            1           1    SIMD LDNP 128-bit

# C6.3.283 STNP (SIMD&FP) C6.3.164 LDNP (SIMD&FP)
# 31 30 29 28 27 26 25 24 23 22 21    15 14    10 9    5 4    0
#  opc   1  0  1  1  0  0  0  L   imm7     Rt2      Rn     Rt

STNPS A64_V 00 10110000 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(8); reg_plus_imm($rn, sextract($imm, 7) * 4); }

LDNPS A64_V 00 10110001 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt; } \
!memory { align(8); reg_plus_imm($rn, sextract($imm, 7) * 4); }

STNPD A64_V 01 10110000 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(16); reg_plus_imm($rn, sextract($imm, 7) * 8); }

LDNPD A64_V 01 10110001 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt; } \
!memory { align(16); reg_plus_imm($rn, sextract($imm, 7) * 8); }

STNPQ A64_V 10 10110000 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(32); reg_plus_imm($rn, sextract($imm, 7) * 16); }

LDNPQ A64_V 10 10110001 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt; } \
!memory { align(32); reg_plus_imm($rn, sextract($imm, 7) * 16); }

# C3.3.8 Load/store register (immediate post-indexed)
# 31 30 29 28 27 26 25 24 23 22 21 20      12 11 10 9    5 4    0
#  size  1  1  1  V  0  0  opc   0    imm9     0  1   Rn     Rt
# merged with 3.3.12

# C3.3.9 Load/store register (immediate pre-indexed)
# 31 30 29 28 27 26 25 24 23 22 21 20      12 11 10 9    5 4    0
#  size  1  1  1  V  0  0  opc   0    imm9     1  1   Rn     Rt
# merged with 3.3.12

# C3.3.10 Load/store register (register offset)
# 31 30 29 28 27 26 25 24 23 22 21 20      16 15     13 12 11 10 9    5 4        0
#  size  1  1  1  V  0  0  opc   1     Rm      option    S  1  0   Rn       Rt
#
#   00            0         00     STRB (register)  -
#   00            0         01     LDRB (register)  -
#   00            0         10     LDRSB (register) 64-bit
#   00            0         11     LDRSB (register) 32-bit
#   01            0         00     STRH (register)  -
#   01            0         01     LDRH (register)  -
#   01            0         10     LDRSH (register) 64-bit
#   01            0         11     LDRSH (register) 32-bit
#   10            0         00     STR (register)   32-bit
#   10            0         01     LDR (register)   32-bit
#   10            0         10     LDRSW (register) -
#   11            0         00     STR (register)   64-bit
#   11            0         01     LDR (register)   64-bit
#   11            0         10     PRFM (register)  -

# XXX opt=011 for now (LSL), other options NIY.
# XXX the constraint rn != rm is our limitation, not imposed by arch.
STRBr A64 00 111000 00 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rm != $rt && $rn != $rm; } \
!memory { align(1); reg_plus_reg_shifted($rn, $rm, $shft ? 0 : 0); }

LDRBr A64 00 111000 01 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rm != $rt && $rn != $rm; } \
!memory { align(1); reg_plus_reg_shifted($rn, $rm, $shft ? 0 : 0); }

LDRSBr A64 00 111000 10 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rm != $rt && $rn != $rm; } \
!memory { align(1); reg_plus_reg_shifted($rn, $rm, $shft ? 0 : 0); }

LDRSBWr A64 00 111000 11 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rm != $rt && $rn != $rm; } \
!memory { align(1); reg_plus_reg_shifted($rn, $rm, $shft ? 0 : 0); }

STRHr A64 01 111000 00 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rm != $rt && $rn != $rm; } \
!memory { align(2); reg_plus_reg_shifted($rn, $rm, $shft ? 1 : 0); }

LDRHr A64 01 111000 01 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rm != $rt && $rn != $rm; } \
!memory { align(2); reg_plus_reg_shifted($rn, $rm, $shft ? 1 : 0); }

LDRSHr A64 01 111000 10 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rm != $rt && $rn != $rm; } \
!memory { align(2); reg_plus_reg_shifted($rn, $rm, $shft ? 1 : 0); }

LDRSHWr A64 01 111000 11 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rm != $rt && $rn != $rm; } \
!memory { align(2); reg_plus_reg_shifted($rn, $rm, $shft ? 1 : 0); }

STRWr A64 10 111000 00 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rm != $rt && $rn != $rm; } \
!memory { align(4); reg_plus_reg_shifted($rn, $rm, $shft ? 2 : 0); }

LDRWr A64 10 111000 01 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rm != $rt && $rn != $rm; } \
!memory { align(4); reg_plus_reg_shifted($rn, $rm, $shft ? 2 : 0); }

LDRSWr A64 10 111000 10 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rm != $rt && $rn != $rm; } \
!memory { align(4); reg_plus_reg_shifted($rn, $rm, $shft ? 2 : 0); }

STRr A64 11 111000 00 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rm != $rt && $rn != $rm; } \
!memory { align(8); reg_plus_reg_shifted($rn, $rm, $shft ? 3 : 0); }

LDRr A64 11 111000 01 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rm != $rt && $rn != $rm; } \
!memory { align(8); reg_plus_reg_shifted($rn, $rm, $shft ? 3 : 0); }

PRFMr A64 11 111000 10 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rm != $rt && $rn != $rm; } \
!memory { align(8); reg_plus_reg_shifted($rn, $rm, $shft ? 3 : 0); }

# C6.3.286 STR (register, SIMD&FP) (register offset)
# 31 30 29 28 27 26 25 24 23 22 21 20       16 15    13 12 11 10 9  5 4  0
#  size  1  1  1  1  0  0  x  0  1     Rm       option   S  1  0  Rn   Rt
#                [V]      [ opc ]
#   00            1         00     SIMD STR (register)  8bit
#   00            1         01     SIMD LDR (register)  8bit
#   01            1         00     SIMD STR (register)  16bit
#   01            1         01     SIMD LDR (register)  16bit
#   10            1         00     SIMD STR (register)  32bit
#   10            1         01     SIMD LDR (register)  32bit
#   11            1         00     SIMD STR (register)  64bit
#   11            1         01     SIMD LDR (register)  64bit
#   00            1         10     SIMD STR (register) 128bit
#   00            1         11     SIMD LDR (register) 128bit
#
# XXX NIY: only LSL option=011 implemented

STRBr A64_V 00 111100 00 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1); reg_plus_reg_shifted($rn, $rm, $shft ? 0 : 0); }

LDRBr A64_V 00 111100 01 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1); reg_plus_reg_shifted($rn, $rm, $shft ? 0 : 0); }

STRHr A64_V 01 111100 00 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(2); reg_plus_reg_shifted($rn, $rm, $shft ? 1 : 0); }

LDRHr A64_V 01 111100 01 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(2); reg_plus_reg_shifted($rn, $rm, $shft ? 1 : 0); }

STRSr A64_V 10 111100 00 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(4); reg_plus_reg_shifted($rn, $rm, $shft ? 2 : 0); }

LDRSr A64_V 10 111100 01 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(4); reg_plus_reg_shifted($rn, $rm, $shft ? 2 : 0); }

STRDr A64_V 11 111100 00 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(8); reg_plus_reg_shifted($rn, $rm, $shft ? 3 : 0); }

LDRDr A64_V 11 111100 01 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(8); reg_plus_reg_shifted($rn, $rm, $shft ? 3 : 0); }

STRQr A64_V 00 111100 10 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(16); reg_plus_reg_shifted($rn, $rm, $shft ? 4 : 0); }

LDRQr A64_V 00 111100 11 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(16); reg_plus_reg_shifted($rn, $rm, $shft ? 4 : 0); }

# C3.3.11 Load/store register (unprivileged)
# 31 30 29 28 27 26 25 24 23 22 21 20      12 11 10 9    5 4        0
#  size  1  1  1  V  0  0  opc   0    imm9     1  0   Rn       Rt
#
#  size           V        opc
#   00            0         00      STTRB   -
#   00            0         01      LDTRB   -
#   00            0         10      LDTRSB  64-bit
#   00            0         11      LDTRSB  32-bit
#   01            0         00      STTRH   -
#   01            0         01      LDTRH   -
#   01            0         10      LDTRSH  64-bit
#   01            0         11      LDTRSH  32-bit
#   10            0         00      STTR    32-bit
#   10            0         01      LDTR    32-bit
#   10            0         10      LDTRSW  -
#   11            0         00      STTR    64-bit
#   11            0         01      LDTR    64-bit

STTRB A64 00 111000 00 0 imm:9 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(1); reg_plus_imm($rn, sextract($imm, 9)); }

LDTRB A64 00 111000 01 0 imm:9 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(1); reg_plus_imm($rn, sextract($imm, 9)); }

LDTRSB A64 00 111000 10 0 imm:9 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(1); reg_plus_imm($rn, sextract($imm, 9)); }

LDTRSBW A64 00 111000 11 0 imm:9 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(1); reg_plus_imm($rn, sextract($imm, 9)); }

STTRH A64 01 111000 00 0 imm:9 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(2); reg_plus_imm($rn, sextract($imm, 9)); }

LDTRH A64 01 111000 01 0 imm:9 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(2); reg_plus_imm($rn, sextract($imm, 9)); }

LDTRSH A64 01 111000 10 0 imm:9 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(2); reg_plus_imm($rn, sextract($imm, 9)); }

LDTRSHW A64 01 111000 11 0 imm:9 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(2); reg_plus_imm($rn, sextract($imm, 9)); }

STTRW A64 10 111000 00 0 imm:9 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(4); reg_plus_imm($rn, sextract($imm, 9)); }

LDTRW A64 10 111000 01 0 imm:9 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(4); reg_plus_imm($rn, sextract($imm, 9)); }

LDTRSW A64 10 111000 10 0 imm:9 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(4); reg_plus_imm($rn, sextract($imm, 9)); }

STTR A64 11 111000 00 0 imm:9 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(8); reg_plus_imm($rn, sextract($imm, 9)); }

LDTR A64 11 111000 01 0 imm:9 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(8); reg_plus_imm($rn, sextract($imm, 9)); }

# C3.3.12 Load/store register (unscaled immediate)
# 31 30 29 28 27 26 25 24 23 22 21 20      12 11 10 9    5 4    0
#  size  1  1  1  V  0  0  opc   0    imm9     0  0   Rn     Rt
# NB: also includes C3.3.8 (immediate post-indexed)
# NB: also includes C3.3.9 (immediate pre-indexed)
# NB: 3.3.8 and 3.3.9 are merged using the idx field.
# NB: the address being accessed is the same with the exception
# NB: of post-indexed, where the address is not offset.
# NB: note that PRFUM has no pre/post version.
#  size           V        opc
#   00            0        00       STURB   -
#   00            0        01       LDURB   -
#   00            0        10       LDURSB  64-bit
#   00            0        11       LDURSB  32-bit
#   01            0        00       STURH   -
#   01            0        01       LDURH   -
#   01            0        10       LDURSH  64-bit
#   01            0        11       LDURSH  32-bit
#   10            0        00       STUR    32-bit
#   10            0        01       LDUR    32-bit
#   10            0        10       LDURSW  -
#   11            0        00       STUR    64-bit
#   11            0        01       LDUR    64-bit
#   11            0        10       PRFUM   -

STURB A64 00 111000 00 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $idx != 2; } \
!memory { align(1); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

LDURB A64 00 111000 01 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $idx != 2; } \
!memory { align(1); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

LDURSB A64 00 111000 10 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $idx != 2; } \
!memory { align(1); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

LDURSBW A64 00 111000 11 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $idx != 2; } \
!memory { align(1); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

STURH A64 01 111000 00 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $idx != 2; } \
!memory { align(2); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

LDURH A64 01 111000 01 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $idx != 2; } \
!memory { align(2); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

LDURSH A64 01 111000 10 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $idx != 2; } \
!memory { align(2); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

LDURSHW A64 01 111000 11 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $idx != 2; } \
!memory { align(2); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

STURW A64 10 111000 00 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $idx != 2; } \
!memory { align(4); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

LDURW A64 10 111000 01 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $idx != 2; } \
!memory { align(4); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

LDURSW A64 10 111000 10 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $idx != 2; } \
!memory { align(4); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

STUR A64 11 111000 00 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $idx != 2; } \
!memory { align(8); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

LDUR A64 11 111000 01 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $idx != 2; } \
!memory { align(8); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

PRFUM A64 11 111000 10 0 imm:9 00 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(8); reg_plus_imm($rn, sextract($imm, 9)); }

# C6.3.287 STUR (SIMD&FP)
# 31 30 29 28 27 26 25 24 23 22 21 20         12 11 10 9  5 4  0
#  size  1  1  1  1  0  0  x  0  0      imm9      0  0  Rn   Rt
#                [V]      [opc ]

STURB A64_V 00 111100 00 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $idx != 2; } \
!memory { align(1); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

LDURB A64_V 00 111100 01 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $idx != 2; } \
!memory { align(1); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

STURH A64_V 01 111100 00 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $idx != 2; } \
!memory { align(2); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

LDURH A64_V 01 111100 01 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $idx != 2; } \
!memory { align(2); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

STURS A64_V 10 111100 00 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $idx != 2; } \
!memory { align(4); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

LDURS A64_V 10 111100 01 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $idx != 2; } \
!memory { align(4); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

STURD A64_V 11 111100 00 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $idx != 2; } \
!memory { align(8); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

LDURD A64_V 11 111100 01 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $idx != 2; } \
!memory { align(8); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

STURQ A64_V 00 111100 10 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $idx != 2; } \
!memory { align(16); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

LDURQ A64_V 00 111100 11 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $idx != 2; } \
!memory { align(16); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

# C3.3.13 Load/store register (unsigned immediate)
# 31 30 29 28 27 26 25 24 23 22 21         10 9    5 4    0
#  size  1  1  1  V  0  1  opc       imm12      Rn     Rt
#   00            0         00  STRB (immediate)
#   00            0         01  LDRB (immediate)
#   00            0         10  LDRSB (immediate)        64-bit
#   00            0         11  LDRSB (immediate)        32-bit
#   01            0         00  STRH (immediate)         Unsigned offset
#   01            0         01  LDRH (immediate)         Unsigned offset
#   01            0         10  LDRSH (immediate)        64-bit
#   01            0         11  LDRSH (immediate)        32-bit
#   10            0         00  STR (immediate)          32-bit
#   10            0         01  LDR (immediate)          32-bit
#   10            0         10  LDRSW (immediate)        Unsigned offset
#   11            0         00  STR (immediate)          64-bit
#   11            0         01  LDR (immediate)          64-bit
#   11            0         10  PRFM (immediate)         -

STRBi A64 00 111001 00 imm:12 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(1); reg_plus_imm($rn, $imm); }

LDRBi A64 00 111001 01 imm:12 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(1); reg_plus_imm($rn, $imm); }

LDRSBi A64 00 111001 10 imm:12 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(1); reg_plus_imm($rn, $imm); }

LDRSBWi A64 00 111001 11 imm:12 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(1); reg_plus_imm($rn, $imm); }

STRHi A64 01 111001 00 imm:12 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(2); reg_plus_imm($rn, $imm * 2); }

LDRHi A64 01 111001 01 imm:12 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(2); reg_plus_imm($rn, $imm * 2); }

LDRSHi A64 01 111001 10 imm:12 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(2); reg_plus_imm($rn, $imm * 2); }

LDRSHWi A64 01 111001 11 imm:12 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(2); reg_plus_imm($rn, $imm * 2); }

STRWi A64 10 111001 00 imm:12 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(4); reg_plus_imm($rn, $imm * 4); }

LDRWi A64 10 111001 01 imm:12 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(4); reg_plus_imm($rn, $imm * 4); }

LDRSWi A64 10 111001 10 imm:12 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(4); reg_plus_imm($rn, $imm * 4); }

STRi A64 11 111001 00 imm:12 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(8); reg_plus_imm($rn, $imm * 8); }

LDRi A64 11 111001 01 imm:12 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(8); reg_plus_imm($rn, $imm * 8); }

PRFMi A64 11 111001 10 imm:12 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(8); reg_plus_imm($rn, $imm * 8); }

# C6.3.285 STR (immediate, SIMD&FP) - Unsigned offset
#  31 30 29 28 27 26 25 24 23 22 21       10 9  5 4  0
#   size  1  1  1  1  0  1  opc     imm12     Rn   Rt
#                 [V]

STRBi A64_V 00 111101 00 imm:12 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1); reg_plus_imm($rn, $imm); }

LDRBi A64_V 00 111101 01 imm:12 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1); reg_plus_imm($rn, $imm); }

STRHi A64_V 01 111101 00 imm:12 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(2); reg_plus_imm($rn, $imm * 2); }

LDRHi A64_V 01 111101 01 imm:12 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(2); reg_plus_imm($rn, $imm * 2); }

STRSi A64_V 10 111101 00 imm:12 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(4); reg_plus_imm($rn, $imm * 4); }

LDRSi A64_V 10 111101 01 imm:12 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(4); reg_plus_imm($rn, $imm * 4); }

STRDi A64_V 11 111101 00 imm:12 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(8); reg_plus_imm($rn, $imm * 8); }

LDRDi A64_V 11 111101 01 imm:12 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(8); reg_plus_imm($rn, $imm * 8); }

STRQi A64_V 00 111101 10 imm:12 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(16); reg_plus_imm($rn, $imm * 16); }

LDRQi A64_V 00 111101 11 imm:12 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(16); reg_plus_imm($rn, $imm * 16); }

# C3.3.14 Load/store register pair (offset)
# 31 30 29 28 27 26 25 24 23 22 21      15 14     10 9    5 4    0
#  opc   1  0  1  V  0  1  0  L    imm7       Rt2      Rn     Rt
#   00            0           0    STP   32-bit
#   00            0           1    LDP   32-bit
#   01            0           1    LDPSW Signed offset
#   10            0           0    STP   64-bit
#   10            0           1    LDP   64-bit
# NB: also includes C3.3.15 (post-indexed)
# NB: also includes C3.3.16 (pre-indexed)
# NB: 3.3.15 and 3.3.16 are merged using the idx field.
# NB: the address being accessed is the same with the exception
# NB: of post-indexed, where the address is not offset.
# NB: note that idx=0 is not included (used for non-temporal pair)

STPW A64 00 101 0 0 idx:2 0 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rn != $rtt && $idx != 0; } \
!memory { align(8); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 7) * 4); }

LDPW A64 00 101 0 0 idx:2 1 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt && $rn != $rt && $rn != $rtt && $idx != 0; } \
!memory { align(8); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 7) * 4); }

LDPSW A64 01 101 0 0 idx:2 1 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt && $rn != $rt && $rn != $rtt && $idx != 0; } \
!memory { align(8); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 7) * 4); }

STP A64 10 101 0 0 idx:2 0 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rn != $rtt && $idx != 0; } \
!memory { align(16); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 7) * 8); }

LDP A64 10 101 0 0 idx:2 1 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt && $rn != $rt && $rn != $rtt && $idx != 0; } \
!memory { align(16); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 7) * 8); }

# C6.3.284 STP (SIMD&FP) post/pre signed offset
# 31 30 29 28 27 26 25 24 23 22 21    15 14   10 9  5 4  0
#  opc   1  0  1  1  0  0  1  0   imm7     Rt2    Rn   Rt
#                [V]   [idx ][L]
STPS A64_V 00 10110 idx:2 0 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $idx != 0; } \
!memory { align(8); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 7) * 4); }

LDPS A64_V 00 10110 idx:2 1 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt && $idx != 0; } \
!memory { align(8); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 7) * 4); }

STPD A64_V 01 10110 idx:2 0 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $idx != 0; } \
!memory { align(16); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 7) * 8); }

LDPD A64_V 01 10110 idx:2 1 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt && $idx != 0; } \
!memory { align(16); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 7) * 8); }

STPQ A64_V 10 10110 idx:2 0 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $idx != 0; } \
!memory { align(32); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 7) * 16); }

LDPQ A64_V 10 10110 idx:2 1 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt && $idx != 0; } \
!memory { align(32); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 7) * 16); }


# - - - 1 0 0 - - - - - - - - - - - - - - - - Data processing - immediate
# C3.4.1 Add/subtract (immediate)
# 31 30 29 | 28 27 26 25 24 |23 22| 21       10 | 9    5 | 4    0
# sf op  S |  1  0  0  0  1 | shft|    imm12    |   Rn   |   Rd

ADDi A64 sf:1 00 10001 0 shft:1 imm:12 rn:5 rd:5 \
!constraints { $rn != 31 && $rd != 31; }

ADDSi A64 sf:1 01 10001 0 shft:1 imm:12 rn:5 rd:5 \
!constraints { $rn != 31 && $rd != 31; }

SUBi A64 sf:1 10 10001 0 shft:1 imm:12 rn:5 rd:5 \
!constraints { $rn != 31 && $rd != 31; }

SUBSi A64 sf:1 11 10001 0 shft:1 imm:12 rn:5 rd:5 \
!constraints { $rn != 31 && $rd != 31; }

# C3.4.2 Bitfield
# 31 | 30 29 | 28 27 26 25 24 23| 22 | 21      16 15      10 9    5 4    0
# sf |  opc  |  1  0  0  1  1  0|  N |    immr       imms      Rn     Rd
#

SBFM A64 sf:1 00 100110 sn:1 immr:6 imms:6 rn:5 rd:5 \
!constraints { \
    ($sf == $sn) && ($sf == 1 || ($immr <= 0x1f && $imms <= 0x1f)); \
}

# ReservedValue: break the ($sf == $sn) constraint
SBFM_RES1 A64 sf:1 00 100110 sn:1 immr:6 imms:6 rn:5 rd:5 \
!constraints { $sf != $sn; }
# ReservedValue: break the ($immr <= 0x1f) constraint
SBFM_RES2 A64 0 00 100110 0 1 immr:5 imms:6 rn:5 rd:5
# ReservedValue: break the ($imms <= 0x1f) constraint
SBFM_RES3 A64 0 00 100110 0 immr:6 1 imms:5 rn:5 rd:5

BFM A64 sf:1 01 100110 sn:1 immr:6 imms:6 rn:5 rd:5 \
!constraints { \
    ($sf == $sn) && ($sf == 1 || ($immr <= 0x1f && $imms <= 0x1f)); \
}

# ReservedValue: break the ($sf == $sn) constraint
BFM_RES1 A64 sf:1 01 100110 sn:1 immr:6 imms:6 rn:5 rd:5 \
!constraints { $sf != $sn; }
# ReservedValue: break the ($immr <= 0x1f) constraint
BFM_RES2 A64 0 01 100110 0 1 immr:5 imms:6 rn:5 rd:5
# ReservedValue: break the ($imms <= 0x1f) constraint
BFM_RES3 A64 0 01 100110 0 immr:6 1 imms:5 rn:5 rd:5

UBFM A64 sf:1 10 100110 sn:1 immr:6 imms:6 rn:5 rd:5 \
!constraints { \
    ($sf == $sn) && ($sf == 1 || ($immr <= 0x1f && $imms <= 0x1f)); \
}

# ReservedValue: break the ($sf == $sn) constraint
UBFM_RES1 A64 sf:1 10 100110 sn:1 immr:6 imms:6 rn:5 rd:5 \
!constraints { $sf != $sn; }
# ReservedValue: break the ($immr <= 0x1f) constraint
UBFM_RES2 A64 0 10 100110 sn:1 1 immr:5 imms:6 rn:5 rd:5
# ReservedValue: break the ($imms <= 0x1f) constraint
UBFM_RES3 A64 0 10 100110 sn:1 immr:6 1 imms:5 rn:5 rd:5

# C3.4.3 Extract
# 31 |30 29| 28 27 26 25 24 23| 22 | 21 | 20    16 15      10 9    5 4    0
# sf |op21 |  1  0  0  1  1  1|  N | o0 |    Rm       imms      Rn     Rd

EXTRW A64 0 00 100111 0 0 rm:5 0 imms:5 rn:5 rd:5

EXTR A64 1 00 100111 1 0 rm:5 imms:6 rn:5 rd:5

# C3.4.4 Logical (immediate)
# 31 |30 29| 28 27 26 25 24 23| 22 | 21      16 15      10 9    5 4    0
# sf |opc  |  1  0  0  1  0  0|  N |    immr       imms      Rn     Rd

ANDi A64 sf:1 00 100100 sn:1 immr:6 imms:6 rn:5 rd:5 \
!constraints { \
    ($rn != 31 && $rd != 31) && \
    (($sf == 0 && $sn == 0 && $imms < 0x1f) || \
     ($sf == 1 && $sn == 1 && $imms < 0x3f)); \
}

# ReservedValue: break the constraint ($sf == $sn)
ANDi_RES1 A64 sf:1 00 100100 sn:1 immr:6 imms:6 rn:5 rd:5 \
!constraints { $sf != $sn; }
# ReservedValue: break the (imms < 0x1f) constraint
ANDi_RES2 A64 0 00 100100 0 immr:6 imms:6 rn:5 rd:5 \
!constraints { $imms >= 0x1f; }
# ReservedValue: break the (imms < 0x3f) constraint
ANDi_RES3 A64 1 00 100100 1 immr:6 111111 rn:5 rd:5

ORRi A64 sf:1 01 100100 sn:1 immr:6 imms:6 rn:5 rd:5 \
!constraints { \
    ($rn != 31 && $rd != 31) && \
    (($sf == 0 && $sn == 0 && $imms < 0x1f) || \
     ($sf == 1 && $sn == 1 && $imms < 0x3f)); \
}

# ReservedValue: break the constraint ($sf == $sn)
ORRi_RES1 A64 sf:1 01 100100 sn:1 immr:6 imms:6 rn:5 rd:5 \
!constraints { $sf != $sn; }
# ReservedValue: break the (imms < 0x1f) constraint
ORRi_RES2 A64 0 01 100100 0 immr:6 imms:6 rn:5 rd:5 \
!constraints { $imms >= 0x1f; }
# ReservedValue: break the (imms < 0x3f) constraint
ORRi_RES3 A64 1 01 100100 1 immr:6 111111 rn:5 rd:5

EORi A64 sf:1 10 100100 sn:1 immr:6 imms:6 rn:5 rd:5 \
!constraints { \
    ($rn != 31 && $rd != 31) && \
    (($sf == 0 && $sn == 0 && $imms < 0x1f) || \
     ($sf == 1 && $sn == 1 && $imms < 0x3f)); \
}

# ReservedValue: break the constraint ($sf == $sn)
EORi_RES1 A64 sf:1 10 100100 sn:1 immr:6 imms:6 rn:5 rd:5 \
!constraints { $sf != $sn; }
# ReservedValue: break the (imms < 0x1f) constraint
EORi_RES2 A64 0 10 100100 0 immr:6 imms:6 rn:5 rd:5 \
!constraints { $imms >= 0x1f; }
# ReservedValue: break the (imms < 0x3f) constraint
EORi_RES3 A64 1 10 100100 1 immr:6 111111 rn:5 rd:5

ANDSi A64 sf:1 11 100100 sn:1 immr:6 imms:6 rn:5 rd:5 \
!constraints { \
    ($rn != 31 && $rd != 31) && \
    (($sf == 0 && $sn == 0 && $imms < 0x1f) || \
     ($sf == 1 && $sn == 1 && $imms < 0x3f)); \
}

# ReservedValue: break the constraint ($sf == $sn)
ANDSi_RES1 A64 sf:1 11 100100 sn:1 immr:6 imms:6 rn:5 rd:5 \
!constraints { $sf != $sn; }
# ReservedValue: break the (imms < 0x1f) constraint
ANDSi_RES2 A64 0 11 100100 0 immr:6 imms:6 rn:5 rd:5 \
!constraints { $imms >= 0x1f; }
# ReservedValue: break the (imms < 0x3f) constraint
ANDSi_RES3 A64 0 11 100100 0 immr:6 111111 rn:5 rd:5

# C3.4.5 Move wide (immediate)
# 31 |30 29| 28 27 26 25 24 23 | 22 21 | 20       5 4    0
# sf |opc  |  1  0  0  1  0  1 |  hw   |    imm16     Rd

MOVN A64 sf:1 00 100101 00 imm:16 rd:5

MOVZ A64 sf:1 10 100101 00 imm:16 rd:5

MOVK A64 sf:1 11 100101 00 imm:16 rd:5

# C3.4.6 PC-rel. addressing NIY

# - - - - 1 0 1 - - - - - - - - - - - - - - - Data processing - register

# C3.5.1 Add/subtract (extended register)
# 31 30 29 28 27 26 25 24 |23 22| 21 | 20    16 15    13 12  10 9    5 4    0
# sf op  S  0  1  0  1  1 | opt |  1 |    Rm     option   imm3    Rn     Rd

ADDx A64 sf:1 00 01011 00 1 rm:5 option:3 imm:3 rn:5 rd:5 \
!constraints { $rn != 31 && $rd != 31 && $imm <= 4; }
# ReservedValue: break the (imm <= 4) constraint
ADDx_RES A64 sf:1 00 01011 00 1 rm:5 option:3 imm:3 rn:5 rd:5 \
!constraints { $imm > 4; }

ADDSx A64 sf:1 01 01011 00 1 rm:5 option:3 imm:3 rn:5 rd:5 \
!constraints { $rn != 31 && $rd != 31 && $imm <= 4; }
# ReservedValue: break the (imm <= 4) constraint
ADDSx_RES A64 sf:1 01 01011 00 1 rm:5 option:3 imm:3 rn:5 rd:5 \
!constraints { $imm > 4; }

SUBx A64 sf:1 10 01011 00 1 rm:5 option:3 imm:3 rn:5 rd:5 \
!constraints { $rn != 31 && $rd != 31 && $imm <= 4; }
# ReservedValue: break the (imm <= 4) constraint
SUBx_RES A64 sf:1 10 01011 00 1 rm:5 option:3 imm:3 rn:5 rd:5 \
!constraints { $imm > 4; }

SUBSx A64 sf:1 11 01011 00 1 rm:5 option:3 imm:3 rn:5 rd:5 \
!constraints { $rn != 31 && $rd != 31 && $imm <= 4; }
# ReservedValue: break the (imm <= 4) constraint
SUBSx_RES A64 sf:1 11 01011 00 1 rm:5 option:3 imm:3 rn:5 rd:5 \
!constraints { $imm > 4; }

# C3.5.2 Add/subtract (shifted register)
# 31 30 29 28 27 26 25 24 |23 22| 21 | 20    16 15      10 9    5 4    0
# sf op  S  0  1  0  1  1 |shift|  0 |    Rm       imm6      Rn     Rd

ADD A64 sf:1 00 01011 shft:2 0 rm:5 imm:6 rn:5 rd:5 \
!constraints { $shft < 3 && ($sf == 1 || $imm <= 0x1f); }
# ReservedValue: break the ($shft < 3) constraint
ADD_RES1 A64 sf:1 00 01011 11 0 rm:5 imm:6 rn:5 rd:5
# ReservedValue: break the ($imm <= 0x1f) constraint
ADD_RES2 A64 0 00 01011 shft:2 0 rm:5 1 imm:5 rn:5 rd:5

ADDS A64 sf:1 01 01011 shft:2 0 rm:5 imm:6 rn:5 rd:5 \
!constraints { $shft < 3 && ($sf == 1 || $imm <= 0x1f); }
# ReservedValue: break the ($shft < 3) constraint
ADDS_RES1 A64 sf:1 01 01011 11 0 rm:5 imm:6 rn:5 rd:5
# ReservedValue: break the ($imm <= 0x1f) constraint
ADDS_RES2 A64 0 01 01011 shft:2 0 rm:5 1 imm:5 rn:5 rd:5

SUB A64 sf:1 10 01011 shft:2 0 rm:5 imm:6 rn:5 rd:5 \
!constraints { $shft < 3 && ($sf == 1 || $imm <= 0x1f); }
# ReservedValue: break the ($shft < 3) constraint
SUB_RES1 A64 sf:1 10 01011 11 0 rm:5 imm:6 rn:5 rd:5
# ReservedValue: break the ($imm <= 0x1f) constraint
SUB_RES2 A64 0 10 01011 shft:2 0 rm:5 1 imm:5 rn:5 rd:5

SUBS A64 sf:1 11 01011 shft:2 0 rm:5 imm:6 rn:5 rd:5 \
!constraints { $shft < 3 && ($sf == 1 || $imm <= 0x1f); }
# ReservedValue: break the ($shft < 3) constraint
SUBS_RES1 A64 sf:1 11 01011 11 0 rm:5 imm:6 rn:5 rd:5
# ReservedValue: break the ($imm <= 0x1f) constraint
SUBS_RES2 A64 0 11 01011 shft:2 0 rm:5 1 imm:5 rn:5 rd:5

# C3.5.3 Add/subtract (with carry)
# 31 30 29 28 27 26 25 24 23 22 21 |20    16 15         10 9    5 4    0
# sf op  S  1  1  0  1  0  0  0  0 |   Rm       opcode2      Rn     Rd

ADC A64 sf:1 00 11010000 rm:5 000000 rn:5 rd:5
ADCS A64 sf:1 01 11010000 rm:5 000000 rn:5 rd:5

SBC A64 sf:1 10 11010000 rm:5 000000 rn:5 rd:5
SBCS A64 sf:1 11 11010000 rm:5 000000 rn:5 rd:5

# C3.5.4 Conditional compare (immediate)

# 31 30 29 28 27 26 25 24 23 22 21 20      16 15      12 11 10 9    5 4 3      0
# sf op  1  1  1  0  1  0  0  1  0    imm5       cond     1  0   Rn   0   nzcv
#
#  0  0     CCMN (immediate) 32-bit
#  0  1     CCMP (immediate) 32-bit
#  1  0     CCMN (immediate) 64-bit
#  1  1     CCMP (immediate) 64-bit

CCMNi A64 sf:1 0 111010010 imm:5 cond:4 10 rn:5 0 nzcv:4
CCMPi A64 sf:1 1 111010010 imm:5 cond:4 10 rn:5 0 nzcv:4

# C3.5.5 Conditional compare (register)
# 31 30 29 28 27 26 25 24 23 22 21 20       16 15      12 11 10 9    5 4 3        0
# sf op  1  1  1  0  1  0  0  1  0      Rm        cond     0  0   Rn   0    nzcv
#  0  0     CCMN (register) 32-bit
#  0  1     CCMP (register) 32-bit
#  1  0     CCMN (register) 64-bit
#  1  1     CCMP (register) 64-bit

CCMN A64 sf:1 0 111010010 rm:5 cond:4 00 rn:5 0 nzcv:4
CCMP A64 sf:1 1 111010010 rm:5 cond:4 00 rn:5 0 nzcv:4

# C3.5.6 Conditional select
# 31 30 29 28 27 26 25 24 23 22 21 |20    16 15      12 11 10 9    5 4    0
# sf op  S  1  1  0  1  0  1  0  0 |   Rm       cond     op2    Rn     Rd

CSEL A64 sf:1 00 11010100 rm:5 cond:4 00 rn:5 rd:5
CSINC A64 sf:1 00 11010100 rm:5 cond:4 01 rn:5 rd:5
CSINV A64 sf:1 10 11010100 rm:5 cond:4 00 rn:5 rd:5
CSNEG A64 sf:1 10 11010100 rm:5 cond:4 01 rn:5 rd:5

# C3.5.7 Data-processing (1 source)
# 31 30 29 28 27 26 25 24 23 22 21 |20         16 15        10 9    5 4    0
# sf  1  S  1  1  0  1  0  1  1  0 |   opcode2       opcode      Rn     Rd

RBIT A64 sf:1 10 11010110 00000 000000 rn:5 rd:5
REV16 A64 sf:1 10 11010110 00000 000001 rn:5 rd:5
REV32 A64 sf:1 10 11010110 00000 000010 rn:5 rd:5
CLZ A64 sf:1 10 11010110 00000 000100 rn:5 rd:5
CLS A64 sf:1 10 11010110 00000 000101 rn:5 rd:5
REV A64 1 10 11010110 00000 000011 rn:5 rd:5

# C3.5.8 Data-processing (2 source)
# 31 30 29 28 27 26 25 24 23 22 21 |20    16 15        10 9    5 4    0
# sf  0  S  1  1  0  1  0  1  1  0 |   Rm       opcode      Rn     Rd

UDIV A64 sf:1 00 11010110 rm:5 000010 rn:5 rd:5
SDIV A64 sf:1 00 11010110 rm:5 000011 rn:5 rd:5
LSLV A64 sf:1 00 11010110 rm:5 001000 rn:5 rd:5
LSRV A64 sf:1 00 11010110 rm:5 001001 rn:5 rd:5
ASRV A64 sf:1 00 11010110 rm:5 001010 rn:5 rd:5
RORV A64 sf:1 00 11010110 rm:5 001011 rn:5 rd:5

# CRC32 availability is implementation-defined, commented out for now
#CRC32B A64 0 00 11010110 rm:5 010000 rn:5 rd:5
#CRC32H A64 0 00 11010110 rm:5 010001 rn:5 rd:5
#CRC32W A64 0 00 11010110 rm:5 010010 rn:5 rd:5
#CRC32CB A64 0 00 11010110 rm:5 010100 rn:5 rd:5
#CRC32CH A64 0 00 11010110 rm:5 010101 rn:5 rd:5
#CRC32CW A64 0 00 11010110 rm:5 010110 rn:5 rd:5
#CRC32X A64 1 00 11010110 rm:5 010011 rn:5 rd:5
#CRC32CX A64 1 00 11010110 rm:5 010111 rn:5 rd:5

# C3.5.9 Data-processing (3 source)
# 31 |30 29| 28 27 26 25 24 |23    21|20    16 15 14    10 9    5 4    0
# sf | op54|  1  1  0  1  1 |  op31  |   Rm    o0    Ra      Rn     Rd

MADD A64 sf:1 00 11011 000 rm:5 0 ra:5 rn:5 rd:5 \
!constraints { $ra != 31; }

MUL A64 sf:1 00 11011 000 rm:5 0 11111 rn:5 rd:5

MSUB A64 sf:1 00 11011 000 rm:5 1 ra:5 rn:5 rd:5 \
!constraints { $ra != 31; }

MNEG A64 sf:1 00 11011 000 rm:5 1 11111 rn:5 rd:5

SMADDL A64 1 00 11011 001 rm:5 0 ra:5 rn:5 rd:5 \
!constraints { $ra != 31; }

SMULL A64 1 00 11011 001 rm:5 0 11111 rn:5 rd:5

SMSUBL A64 1 00 11011 001 rm:5 1 ra:5 rn:5 rd:5 \
!constraints { $ra != 31; }

SMNEGL A64 1 00 11011 001 rm:5 1 11111 rn:5 rd:5

SMULH A64 1 00 11011 010 rm:5 0 ra:5 rn:5 rd:5

UMADDL A64 1 00 11011 101 rm:5 0 ra:5 rn:5 rd:5 \
!constraints { $ra != 31; }

UMULL A64 1 00 11011 101 rm:5 0 11111 rn:5 rd:5

UMSUBL A64 1 00 11011 101 rm:5 1 ra:5 rn:5 rd:5 \
!constraints { $ra != 31; }

UMNEGL A64 1 00 11011 101 rm:5 1 11111 rn:5 rd:5

UMULH A64 1 00 11011 110 rm:5 0 ra:5 rn:5 rd:5

# C3.5.10 Logical (shifted register)
# 31|30 29| 28 27 26 25 24 |23 22| 21| 20    16 15      10 9    5 4    0
# sf| opc |  0  1  0  1  0 |shift|  N|    Rm       imm6      Rn     Rd

AND A64 sf:1 00 01010 shft:2 0 rm:5 imm:6 rn:5 rd:5 \
!constraints { $sf == 1 || $imm <= 0x1f; }
# ReservedValue: break the ($imm <= 0x1f) constraint
AND_RES A64 0 00 01010 shft:2 0 rm:5 1 imm:5 rn:5 rd:5

BIC A64 sf:1 00 01010 shft:2 1 rm:5 imm:6 rn:5 rd:5 \
!constraints { $sf == 1 || $imm <= 0x1f; }
# ReservedValue: break the ($imm <= 0x1f) constraint
BIC_RES A64 0 00 01010 shft:2 1 rm:5 1 imm:5 rn:5 rd:5

ORR A64 sf:1 01 01010 shft:2 0 rm:5 imm:6 rn:5 rd:5 \
!constraints { $sf == 1 || $imm <= 0x1f; }
# ReservedValue: break the ($imm <= 0x1f) constraint
ORR_RES A64 0 01 01010 shft:2 0 rm:5 1 imm:5 rn:5 rd:5

ORN A64 sf:1 01 01010 shft:2 1 rm:5 imm:6 rn:5 rd:5 \
!constraints { $rn != 31 && ($sf == 1 || $imm <= 0x1f); }
# ReservedValue: break the ($imm <= 0x1f) constraint
ORN_RES A64 0 01 01010 shft:2 1 rm:5 1 imm:5 rn:5 rd:5

MVN A64 sf:1 01 01010 shft:2 1 rm:5 imm:6 11111 rd:5 \
!constraints { $sf == 1 || $imm <= 0x1f; }
# ReservedValue: break the ($imm <= 0x1f) constraint
MVN_RES A64 0 01 01010 shft:2 1 rm:5 1 imm:5 11111 rd:5

EOR A64 sf:1 10 01010 shft:2 0 rm:5 imm:6 rn:5 rd:5 \
!constraints { $sf == 1 || $imm <= 0x1f; }
# ReservedValue: break the ($imm <= 0x1f) constraint
EOR_RES A64 0 10 01010 shft:2 0 rm:5 1 imm:5 rn:5 rd:5

EON A64 sf:1 10 01010 shft:2 1 rm:5 imm:6 rn:5 rd:5 \
!constraints { $sf == 1 || $imm <= 0x1f; }
# ReservedValue: break the ($imm <= 0x1f) constraint
EON_RES A64 0 10 01010 shft:2 1 rm:5 1 imm:5 rn:5 rd:5

ANDS A64 sf:1 11 01010 shft:2 0 rm:5 imm:6 rn:5 rd:5 \
!constraints { $sf == 1 || $imm <= 0x1f; }
# ReservedValue: break the ($imm <= 0x1f) constraint
ANDS_RES A64 0 11 01010 shft:2 0 rm:5 1 imm:5 rn:5 rd:5

BICS A64 sf:1 11 01010 shft:2 1 rm:5 imm:6 rn:5 rd:5 \
!constraints { $sf == 1 || $imm <= 0x1f; }
# ReservedValue: break the ($imm <= 0x1f) constraint
BICS_RES A64 0 11 01010 shft:2 1 rm:5 1 imm:5 rn:5 rd:5

# C3.6 Data processing - SIMD and floating point

# C3.6.1 AdvSIMD EXT
# 31 30 29 28 27 26 25 24 23 22 21 20  16|15|14    11|10|9  5 4  0
#  0  Q  1  0  1  1  1  0  0  0  0   Rm  | 0|  imm4  | 0| Rn   Rd

# XXX BUG in objdump / libopcode? $Q==1 && $imm & 0x08 should be allowed,
# instead the instruction shows as undefined. Check again with latest objdump.
# problem encountered with linaro aarch64 cross objdump
# crosstool-NG linaro-1.13.1-4.7-2013.01-20130125 - 2.23.51.20121016
# XXX
# 1a59c:       6e0e72f9        .inst   0x6e0e72f9 ; undefined [XXX]

EXT A64_V 0 Q:1 101110000 rm:5 0 imm:4 0 rn:5 rd:5 \
!constraints { !($imm & 0x08); }

# C3.6.2 AdvSIMD TBL/TBX
# 31 30 29 28 27 26 25 24 23 22 21 20  16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  1  0  0  0  0   Rm    0  len  op  0  0  Rn   Rd

TBL A64_V 0 Q:1 001110000 rm:5 0 len:2 0 00 rn:5 rd:5
TBX A64_V 0 Q:1 001110000 rm:5 0 len:2 1 00 rn:5 rd:5

# C3.6.3 AdvSIMD ZIP/UZP/TRN
# 31 30 29 28 27 26 25 24 23 22 21 20  16 15 14   12 11 10 9  5 4  0
#  0  Q  0  0  1  1  1  0  size  0   Rm    0 opcode   1  0  Rn   Rd

UZP1 A64_V 0 Q:1 001110 size:2 0 rm:5 0 001 10 rn:5 rd:5 \
!constraints { !($size == 3 && $Q == 0); }
# ReservedValue: break the !($size == 3 && $Q == 0) constraint
UZP1_RES A64_V 0 0 001110 11 0 rm:5 0 001 10 rn:5 rd:5

TRN1 A64_V 0 Q:1 001110 size:2 0 rm:5 0 010 10 rn:5 rd:5 \
!constraints { !($size == 3 && $Q == 0); }
# ReservedValue: break the !($size == 3 && $Q == 0) constraint
TRN1_RES A64_V 0 0 001110 11 0 rm:5 0 010 10 rn:5 rd:5

ZIP1 A64_V 0 Q:1 001110 size:2 0 rm:5 0 011 10 rn:5 rd:5 \
!constraints { !($size == 3 && $Q == 0); }
# ReservedValue: break the !($size == 3 && $Q == 0) constraint
ZIP1_RES A64_V 0 0 001110 11 0 rm:5 0 011 10 rn:5 rd:5

UZP2 A64_V 0 Q:1 001110 size:2 0 rm:5 0 101 10 rn:5 rd:5 \
!constraints { !($size == 3 && $Q == 0); }
# ReservedValue: break the !($size == 3 && $Q == 0) constraint
UZP2_RES A64_V 0 0 001110 11 0 rm:5 0 101 10 rn:5 rd:5

TRN2 A64_V 0 Q:1 001110 size:2 0 rm:5 0 110 10 rn:5 rd:5 \
!constraints { !($size == 3 && $Q == 0); }
# ReservedValue: break the !($size == 3 && $Q == 0) constraint
TRN2_RES A64_V 0 0 001110 11 0 rm:5 0 110 10 rn:5 rd:5

ZIP2 A64_V 0 Q:1 001110 size:2 0 rm:5 0 111 10 rn:5 rd:5 \
!constraints { !($size == 3 && $Q == 0); }
# ReservedValue: break the !($size == 3 && $Q == 0) constraint
ZIP2_RES A64_V 0 0 001110 11 0 rm:5 0 111 10 rn:5 rd:5

# C3.6.4 AdvSIMD across lanes
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16  12 11 10 9  5 4  0
#  0  Q  U  0  1  1  1  0  size  1  1  0  0  0 opcode  1  0  Rn   Rd

SADDLV A64_V 0 Q:1 0 01110 size:2 11000 00011 10 rn:5 rd:5 \
!constraints { $size < 2 || ($size == 2 && $Q == 1); }
# ReservedValue: break the constraint (size==2) => (Q=1)
SADDLV_RES A64_V 0 0 0 01110 10 11000 00011 10 rn:5 rd:5

SMAXV A64_V 0 Q:1 0 01110 size:2 11000 01010 10 rn:5 rd:5 \
!constraints { $size < 2 || ($size == 2 && $Q == 1); }
# ReservedValue: break the constraint (size==2) => (Q=1)
SMAXV_RES A64_V 0 0 0 01110 10 11000 01010 10 rn:5 rd:5

SMINV A64_V 0 Q:1 0 01110 size:2 11000 11010 10 rn:5 rd:5 \
!constraints { $size < 2 || ($size == 2 && $Q == 1); }
# ReservedValue: break the constraint (size==2) => (Q=1)
SMINV_RES A64_V 0 0 0 01110 10 11000 11010 10 rn:5 rd:5

ADDV A64_V 0 Q:1 0 01110 size:2 11000 11011 10 rn:5 rd:5 \
!constraints { $size < 2 || ($size == 2 && $Q == 1); }
# ReservedValue: break the constraint (size==2) => (Q=1)
ADDV_RES A64_V 0 0 0 01110 10 11000 11011 10 rn:5 rd:5

UADDLV A64_V 0 Q:1 1 01110 size:2 11000 00011 10 rn:5 rd:5 \
!constraints { $size < 2 || ($size == 2 && $Q == 1); }
# ReservedValue: break the constraint (size==2) => (Q=1)
UADDLV_RES A64_V 0 0 1 01110 10 11000 00011 10 rn:5 rd:5

UMAXV A64_V 0 Q:1 1 01110 size:2 11000 01010 10 rn:5 rd:5 \
!constraints { $size < 2 || ($size == 2 && $Q == 1); }
# ReservedValue: break the constraint (size==2) => (Q=1)
UMAXV_RES A64_V 0 0 1 01110 10 11000 01010 10 rn:5 rd:5

UMINV A64_V 0 Q:1 1 01110 size:2 11000 11010 10 rn:5 rd:5 \
!constraints { $size < 2 || ($size == 2 && $Q == 1); }
# ReservedValue: break the constraint (size==2) => (Q=1)
UMINV_RES A64_V 0 0 1 01110 10 11000 11010 10 rn:5 rd:5

FMAXNMV A64_V 0 1 1 01110 00 11000 01100 10 rn:5 rd:5
FMAXV A64_V 0 1 1 01110 00 11000 01111 10 rn:5 rd:5

FMINNMV A64_V 0 1 1 01110 10 11000 01100 10 rn:5 rd:5
FMINV A64_V 0 1 1 01110 10 11000 01111 10 rn:5 rd:5

# C3.6.5 AdvSIMD copy
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15 14    11 10 9  5 4  0
#  0  Q op  0  1  1  1  0  0  0  0   imm5    0   imm4    1  Rn   Rd

DUPe A64_V 0 Q:1 0 01110000 imm:5 0 0000 1 rn:5 rd:5 \
!constraints { ($imm & 0x07) || (($imm & 0x0f) && $Q == 1); }
# ReservedValue: break the constraint (imm & 0x0f) => (Q == 1)
DUPe_RES1 A64_V 0 0 0 01110000 imm:1 1000 0 0000 1 rn:5 rd:5
# ReservedValue: break the constraint ((imm & 0x0f) != 0)
DUPe_RES2 A64_V 0 Q:1 0 01110000 imm:1 0000 0 0000 1 rn:5 rd:5

DUP A64_V 0 Q:1 0 01110000 imm:5 0 0001 1 rn:5 rd:5 \
!constraints { ($imm & 0x07) || (($imm & 0x0f) && $Q == 1); }
# ReservedValue: break the constraint (imm & 0x0f) => (Q == 1)
DUP_RES1 A64_V 0 0 0 01110000 imm:1 1000 0 0001 1 rn:5 rd:5
# ReservedValue: break the constraint ((imm & 0x0f) != 0)
DUP_RES2 A64_V 0 Q:1 0 01110000 imm:1 0000 0 0001 1 rn:5 rd:5

SMOV A64_V 0 Q:1 0 01110000 imm:5 0 0101 1 rn:5 rd:5 \
!constraints { ($imm & 0x03) || (($imm & 0x07) && $Q == 1); }
# ReservedValue: break the constraint (imm & 0x07) => (Q == 1)
SMOV_RES1 A64_V 0 0 0 01110000 imm:2 100 0 0101 1 rn:5 rd:5
# ReservedValue: break the constraint ((imm & 0x07) != 0)
SMOV_RES2 A64_V 0 Q:1 0 01110000 imm:2 000 0 0101 1 rn:5 rd:5

UMOV A64_V 0 Q:1 0 01110000 imm:5 0 0111 1 rn:5 rd:5 \
!constraints { ($Q == 0 && ($imm & 0x07)) || ($Q == 1 && (($imm & 0x0f) == 0x80)); }
# ReservedValue: break the constraint ($Q == 0) => ($imm & 0x07)
UMOV_RES1 A64_V 0 0 0 01110000 imm:2 000 0 0111 1 rn:5 rd:5
# ReservedValue: break the constraint ($Q == 1) => (($imm & 0x0f) == 0x80)
UMOV_RES2 A64_V 0 1 0 01110000 imm:5 0 0111 1 rn:5 rd:5 \
!constraints { ($imm & 0x0f) != 0x80; }

INS A64_V 0 1 0 01110000 imm:5 0 0011 1 rn:5 rd:5 \
!constraints { ($imm & 0x0f); }
# ReservedValue: break the constraint ($imm & 0x0f)
INS_RES A64_V 0 1 0 01110000 imm:1 0000 0 0011 1 rn:5 rd:5

INSe A64_V 0 1 1 01110000 imm:5 0 immm:4 1 rn:5 rd:5 \
!constraints { ($imm & 0x0f); }
# ReservedValue: break the constraint ($imm & 0x0f)
INSe_RES A64_V 0 1 1 01110000 imm:1 0000 0 immm:4 1 rn:5 rd:5

# C3.6.6 AdvSIMD modified immediate
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16  15     12  11 10 9 8 7 6 5 4  0
#  0  Q op  0  1  1  1  1  0  0  0  0  0  a  b  c [  cmode  ] o2  1 d e f g h  Rd

# NIY

# C3.6.25 Floating-point data-processing (1 source)
# 31 30 29 28 27 26 25 24 |23 22| 21 20        15 14 13 12 11 10 9  5 4  0
#  M  0  S  1  1  1  1  0 |type |  1    opcode     1  0  0  0  0  Rn   Rd

# FMOV (register) opc = 0
FMOV A64_V 00011110 type:2 1 0000 00 10000 rn:5 rd:5 \
!constraints { $type < 2; }
# UnallocatedEncoding: type >= 2
FMOV_RES A64_V 00011110 1 type:1 1 0000 00 10000 rn:5 rd:5

# FABS (scalar) opc = 1
FABS A64_V 00011110 type:2 1 0000 01 10000 rn:5 rd:5 \
!constraints { $type < 2; }
# UnallocatedEncoding: type >= 2
FABS_RES A64_V 00011110 1 type:1 1 0000 01 10000 rn:5 rd:5

# FNEG (scalar) opc = 2
FNEG A64_V 00011110 type:2 1 0000 10 10000 rn:5 rd:5 \
!constraints { $type < 2; }
# UnallocatedEncoding: type >= 2
FNEG_RES A64_V 00011110 1 type:1 1 0000 10 10000 rn:5 rd:5

# FSQRT (scalar) opc = 3
FSQRT A64_V 00011110 type:2 1 0000 11 10000 rn:5 rd:5 \
!constraints { $type < 2; }
# UnallocatedEncoding: type >= 2
FSQRT_RES A64_V 00011110 1 type:1 1 0000 11 10000 rn:5 rd:5

# FCVT (all forms) - NB: conversion with src = dst is not allowed
FCVT A64_V 00011110 type:2 1 0001 opc:2 10000 rn:5 rd:5 \
!constraints { $type != 2 && $opc != 2 && $type != $opc; }
# UnallocatedEncoding: type == 2
FCVT_RES1 A64_V 00011110 10 1 0001 opc:2 10000 rn:5 rd:5
# UnallocatedEncoding: opc == 2
FCVT_RES2 A64_V 00011110 type:2 1 0001 10 10000 rn:5 rd:5
# UnallocatedEncoding: type == opc
FCVT_RES3 A64_V 00011110 type:2 1 0001 opc:2 10000 rn:5 rd:5 \
!constraints { $type == $opc; }

# FRINT (scalar), all rounding modes
FRINT A64_V 00011110 type:2 1 001 mode:3 10000 rn:5 rd:5 \
!constraints { $type < 2 && $mode != 5; }
# UnallocatedEncoding: type >= 2
FRINT_RES1 A64_V 00011110 1 type:1 1 001 mode:3 10000 rn:5 rd:5
# UnallocatedEncoding: rounding mode == 5
FRINT_RES2 A64_V 00011110 type:2 1 001 101 10000 rn:5 rd:5

# C3.6.26 Floating-point data-processing (2 source)
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15      12 11 10 9  5 4  0
#  M  0  S  1  1  1  1  0  type  1    Rm      opcode    1  0  Rn   Rd

# FMUL (scalar)
FMUL A64_V 00011110 type:2 1 rm:5 0000 10 rn:5 rd:5 \
!constraints { $type < 2; }
# UnallocatedEncoding: type >= 2
FMUL_RES A64_V 00011110 1 type:1 1 rm:5 0000 10 rn:5 rd:5

# FDIV (scalar)
FDIV A64_V 00011110 type:2 1 rm:5 0001 10 rn:5 rd:5 \
!constraints { $type < 2; }
# UnallocatedEncoding: type >= 2
FDIV_RES A64_V 00011110 1 type:1 1 rm:5 0001 10 rn:5 rd:5

# FADD (scalar)
FADD A64_V 00011110 type:2 1 rm:5 0010 10 rn:5 rd:5 \
!constraints { $type < 2; }
# UnallocatedEncoding: type >= 2
FADD_RES A64_V 00011110 1 type:1 1 rm:5 0010 10 rn:5 rd:5

# FSUB (scalar)
FSUB A64_V 00011110 type:2 1 rm:5 0011 10 rn:5 rd:5 \
!constraints { $type < 2; }
# UnallocatedEncoding: type >= 2
FSUB_RES A64_V 00011110 1 type:1 1 rm:5 0011 10 rn:5 rd:5

# FMAX (scalar)
FMAX A64_V 00011110 type:2 1 rm:5 0100 10 rn:5 rd:5 \
!constraints { $type < 2; }
# UnallocatedEncoding: type >= 2
FMAX_RES A64_V 00011110 1 type:1 1 rm:5 0100 10 rn:5 rd:5

# FMIN (scalar)
FMIN A64_V 00011110 type:2 1 rm:5 0101 10 rn:5 rd:5 \
!constraints { $type < 2; }
# UnallocatedEncoding: type >= 2
FMIN_RES A64_V 00011110 1 type:1 1 rm:5 0101 10 rn:5 rd:5

# FMAXNM (scalar)
FMAXNM A64_V 00011110 type:2 1 rm:5 0110 10 rn:5 rd:5 \
!constraints { $type < 2; }
# UnallocatedEncoding: type >= 2
FMAXNM_RES A64_V 00011110 1 type:1 1 rm:5 0110 10 rn:5 rd:5

# FMINNM (scalar)
FMINNM A64_V 00011110 type:2 1 rm:5 0111 10 rn:5 rd:5 \
!constraints { $type < 2; }
# UnallocatedEncoding: type >= 2
FMINNM_RES A64_V 00011110 1 type:1 1 rm:5 0111 10 rn:5 rd:5

# FNMUL (scalar)
FNMUL A64_V 00011110 type:2 1 rm:5 1000 10 rn:5 rd:5 \
!constraints { $type < 2; }
# UnallocatedEncoding: type >= 2
FNMUL_RES A64_V 00011110 1 type:1 1 rm:5 1000 10 rn:5 rd:5

# C3.6.27 Floating-point data-processing (3 source)
# 31 30 29 28 27 26 25 24 23 22 21 20  16 15 14  10 9  5 4  0
#  M  0  S  1  1  1  1  1 type  o1   Rm   o0   Ra    Rn   Rd

FMADD A64_V 00011111 type:2 0 rm:5 0 ra:5 rn:5 rd:5 \
!constraints { $type < 2; }
# UnallocatedEncoding: type >= 2
FMADD_RES A64_V 00011111 1 type:1 0 rm:5 0 ra:5 rn:5 rd:5

FMSUB A64_V 00011111 type:2 0 rm:5 1 ra:5 rn:5 rd:5 \
!constraints { $type < 2; }
# UnallocatedEncoding: type >= 2
FMSUB_RES A64_V 00011111 1 type:1 0 rm:5 1 ra:5 rn:5 rd:5

FNMADD A64_V 00011111 type:2 1 rm:5 0 ra:5 rn:5 rd:5 \
!constraints { $type < 2; }
# UnallocatedEncoding: type >= 2
FNMADD_RES A64_V 00011111 1 type:1 1 rm:5 0 ra:5 rn:5 rd:5

FNMSUB A64_V 00011111 type:2 1 rm:5 1 ra:5 rn:5 rd:5 \
!constraints { $type < 2; }
# UnallocatedEncoding: type >= 2
FNMSUB_RES A64_V 00011111 1 type:1 1 rm:5 1 ra:5 rn:5 rd:5
