###############################################################################
# Copyright (c) 2010 Linaro Limited
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the Eclipse Public License v1.0
# which accompanies this distribution, and is available at
# http://www.eclipse.org/legal/epl-v10.html
#
# Contributors:
#     Claudio Fontana - initial implementation
#     based on arm.risu by Peter Maydell
###############################################################################

# Input file for risugen defining AArch64 instructions
.mode aarch64

# from ARM DDI 0487A.a ARM Architecture Reference Manual
# NIY: PC-related instructions
# NIY: SP-related instructions
# NIY: flags-related instructions
# NIY: floating point and SIMD

# - - - - 1 - 0 - - - - - - - - - - - - - - - Loads and stores
# C3.3 Loads and stores
# NIY: SIMD & FP instructions and variants

# C3.3.5 Load register (PC-relative literal)
# 31 30 29 28 27 26 25 24 23       5 4    0
#  opc   0  1  1  V  0  0    imm19     Rt
#
# XXX claudio NIY: problematic, as we need to reach the memblock
# as a PC-relative immediate offset, and check the
# constraints (whether it fits in immx).
# Might require a new network API (GET_MEMBLOCK_PCREL_nbits), which
# could fail if out of range.
#
# LDR_L A64 opc:2 0110 00 imm:19 rt:5 \
# !constraints { $opc != 0x3; } \
# !memory { pc_adr(); }
# PRFM_L A64 11 0 110 00 imm:19 rt:5

# C3.3.7 Load/store no-allocate pair (offset)
# 31 30 29 28 27 26 25 24 23 22 21      15 14     10 9    5 4    0
#  opc   1  0  1  V  0  0  0  L    imm7       Rt2      Rn     Rt
#
# XXX claudio NIY: we cannot compare results as the hint could be
# wrong, we do not analyze the code to the level that is required.
#

# C3.3.6 Load/store exclusive
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15 14     10 9    5 4    0
#  size  0  0  1  0  0  0 o2  L o1    Rs    o0    Rt2      Rn     Rt

# size o2 L o1 o0
#  00   0  0 0  0  STXRB            -
#  00   0  0 0  1  STLXRB           -
#  00   1  0 0  1  STLRB            -

#  01   0  0 0  0  STXRH            -
#  01   0  0 0  1  STLXRH           -
#  01   1  0 0  1  STLRH            -

#  00   0  1 0  0  LDXRB            -
#  00   0  1 0  1  LDAXRB           -
#  00   1  1 0  1  LDARB            -

#  01   0  1 0  0  LDXRH            -
#  01   0  1 0  1  LDAXRH           -
#  01   1  1 0  1  LDARH            -

#  10   0  0 0  0  STXR        32-bit
#  10   0  0 0  1  STLXR       32-bit
#  10   1  0 0  1  STLR        32-bit

#  10   0  1 0  0  LDXR        32-bit
#  10   0  1 0  1  LDAXR       32-bit
#  10   1  1 0  1  LDAR        32-bit

#  11   0  0 0  0  STXR        64-bit
#  11   0  0 0  1  STLXR       64-bit
#  11   1  0 0  1  STLR        64-bit

#  11   0  1 0  0  LDXR        64-bit
#  11   0  1 0  1  LDAXR       64-bit
#  11   1  1 0  1  LDAR        64-bit

# data is in rt, base address in rn, status written to rs
STXRB A64 00 001000 000 rs:5 0 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rn; } \
!memory { align(1); reg($rn); }

STLXRB A64 00 001000 000 rs:5 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rn; } \
!memory { align(1); reg($rn); }

STLRB A64 00 001000 100 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1); reg($rn); }

STXRH A64 01 001000 000 rs:5 0 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rn; } \
!memory { align(2); reg($rn); }

STLXRH A64 01 001000 000 rs:5 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rn } \
!memory { align(2); reg($rn); }

STLRH A64 01 001000 100 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(2); reg($rn); }

LDXRB A64 00 001000 010 11111 0 11111 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1); reg($rn); }

LDAXRB A64 00 001000 010 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1); reg($rn); }

LDARB A64 00 001000 110 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1); reg($rn); }

LDXRH A64 01 001000 010 11111 0 11111 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(2); reg($rn); }

LDAXRH A64 01 001000 010 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(2); reg($rn); }

LDARH A64 01 001000 110 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(2); reg($rn); }

STXR32 A64 10 001000 000 rs:5 0 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rn; } \
!memory { align(4); reg($rn); }

STLXR32 A64 10 001000 000 rs:5 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rn; } \
!memory { align(4); reg($rn); }

STLR32 A64 10 001000 100 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(4); reg($rn); }

LDXR32 A64 10 001000 010 11111 0 11111 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(4); reg($rn); }

LDAXR32 A64 10 001000 010 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(4); reg($rn); }

LDAR32 A64 10 001000 110 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(4); reg($rn); }

STXR64 A64 11 001000 000 rs:5 0 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rn; } \
!memory { align(8); reg($rn); }

STLXR64 A64 11 001000 000 rs:5 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rn; } \
!memory { align(8); reg($rn); }

STLR64 A64 11 001000 100 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(8); reg($rn); }

LDXR64 A64 11 001000 010 11111 0 11111 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(8); reg($rn); }

LDAXR64 A64 11 001000 010 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(8); reg($rn); }

LDAR64 A64 11 001000 110 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(8); reg($rn); }

#  Now with P (pair load/stores):
#  10   0  0 1  0  STXP        32-bit
#  10   0  0 1  1  STLXP       32-bit

#  10   0  1 1  0  LDXP        32-bit
#  10   0  1 1  1  LDAXP       32-bit

#  11   0  0 1  0  STXP        64-bit
#  11   0  0 1  1  STLXP       64-bit

#  11   0  1 1  0  LDXP        64-bit
#  11   0  1 1  1  LDAXP       64-bit

STXP32 A64 10 001000 001 rs:5 0 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rtt && $rs != $rn; } \
!memory { align(8); reg($rn); }

STLXP32 A64 10 001000 001 rs:5 1 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rtt && $rs != $rn; } \
!memory { align(8); reg($rn); }

LDXP32 A64 10 001000 011 11111 0 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt; } \
!memory { align(8); reg($rn); }

LDAXP32 A64 10 001000 011 11111 1 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt; } \
!memory { align(8); reg($rn); }

STXP64 A64 11 001000 001 rs:5 0 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rtt && $rs != $rn; } \
!memory { align(16); reg($rn); }

STLXP64 A64 11 001000 001 rs:5 1 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rtt && $rs != $rn; } \
!memory { align(16); reg($rn); }

LDXP64 A64 11 001000 011 11111 0 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt; } \
!memory { align(16); reg($rn); }

LDAXP64 A64 11 001000 011 11111 1 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt; } \
!memory { align(16); reg($rn); }

# - - - 1 0 0 - - - - - - - - - - - - - - - - Data processing - immediate
# C3.4.1 Add/subtract (immediate)
# 31 30 29 | 28 27 26 25 24 |23 22| 21       10 | 9    5 | 4    0
# sf op  S |  1  0  0  0  1 | shft|    imm12    |   Rn   |   Rd

ADDi A64 sf:1 00 10001 0 shft:1 imm:12 rn:5 rd:5 \
!constraints { $rn != 31 && $rd != 31; }

SUBi A64 sf:1 10 10001 0 shft:1 imm:12 rn:5 rd:5 \
!constraints { $rn != 31 && $rd != 31; }

# C3.4.2 Bitfield
# 31 | 30 29 | 28 27 26 25 24 23| 22 | 21      16 15      10 9    5 4    0
# sf |  opc  |  1  0  0  1  1  0|  N |    immr       imms      Rn     Rd
#
SBFM A64 sf:1 00 100110 sn:1 immr:6 imms:6 rn:5 rd:5 \
!constraints { \
    ($sf == $sn) && ($sf == 1 || ($immr <= 0x1f && $imms <= 0x1f)); \
}

BFM A64 sf:1 01 100110 sn:1 immr:6 imms:6 rn:5 rd:5 \
!constraints { \
    ($sf == $sn) && ($sf == 1 || ($immr <= 0x1f && $imms <= 0x1f)); \
}

UBFM A64 sf:1 10 100110 sn:1 immr:6 imms:6 rn:5 rd:5 \
!constraints { \
    ($sf == $sn) && ($sf == 1 || ($immr <= 0x1f && $imms <= 0x1f)); \
}

# C3.4.3 Extract
# 31 |30 29| 28 27 26 25 24 23| 22 | 21 | 20    16 15      10 9    5 4    0
# sf |op21 |  1  0  0  1  1  1|  N | o0 |    Rm       imms      Rn     Rd

EXTR32 A64 0 00 100111 0 0 rm:5 0 imms:5 rn:5 rd:5

EXTR64 A64 1 00 100111 1 0 rm:5 imms:6 rn:5 rd:5

# C3.4.4 Logical (immediate)
# 31 |30 29| 28 27 26 25 24 23| 22 | 21      16 15      10 9    5 4    0
# sf |opc  |  1  0  0  1  0  0|  N |    immr       imms      Rn     Rd

ANDi A64 sf:1 00 100100 sn:1 immr:6 imms:6 rn:5 rd:5 \
!constraints { \
    ($rn != 31 && $rd != 31) && \
    (($sf == 0 && $sn == 0 && $imms < 0x1f) || \
     ($sf == 1 && $sn == 1 && $imms < 0x3f)); \
}

ORRi A64 sf:1 01 100100 sn:1 immr:6 imms:6 rn:5 rd:5 \
!constraints { \
    ($rn != 31 && $rd != 31) && \
    (($sf == 0 && $sn == 0 && $imms < 0x1f) || \
     ($sf == 1 && $sn == 1 && $imms < 0x3f)); \
}

EORi A64 sf:1 10 100100 sn:1 immr:6 imms:6 rn:5 rd:5 \
!constraints { \
    ($rn != 31 && $rd != 31) && \
    (($sf == 0 && $sn == 0 && $imms < 0x1f) || \
     ($sf == 1 && $sn == 1 && $imms < 0x3f)); \
}

# C3.4.5 Move wide (immediate)
# 31 |30 29| 28 27 26 25 24 23 | 22 21 | 20       5 4    0
# sf |opc  |  1  0  0  1  0  1 |  hw   |    imm16     Rd

MOVN A64 sf:1 00 100101 00 imm:16 rd:5

MOVZ A64 sf:1 10 100101 00 imm:16 rd:5

MOVK A64 sf:1 11 100101 00 imm:16 rd:5

# C3.4.6 PC-rel. addressing NIY

# - - - - 1 0 1 - - - - - - - - - - - - - - - Data processing - register

# C3.5.1 Add/subtract (extended register)
# 31 30 29 28 27 26 25 24 |23 22| 21 | 20    16 15    13 12  10 9    5 4    0
# sf op  S  0  1  0  1  1 | opt |  1 |    Rm     option   imm3    Rn     Rd

ADDx A64 sf:1 00 01011 00 1 rm:5 option:3 imm:3 rn:5 rd:5 \
!constraints { $rn != 31 && $rd != 31 && $imm <= 4; }

SUBx A64 sf:1 10 01011 00 1 rm:5 option:3 imm:3 rn:5 rd:5 \
!constraints { $rn != 31 && $rd != 31 && $imm <= 4; }

# C3.5.2 Add/subtract (shifted register)
# 31 30 29 28 27 26 25 24 |23 22| 21 | 20    16 15      10 9    5 4    0
# sf op  S  0  1  0  1  1 |shift|  0 |    Rm       imm6      Rn     Rd

ADD A64 sf:1 00 01011 shft:2 0 rm:5 imm:6 rn:5 rd:5 \
!constraints { $shft < 3 && ($sf == 1 || $imm <= 0x1f); }

SUB A64 sf:1 10 01011 shft:2 0 rm:5 imm:6 rn:5 rd:5 \
!constraints { $shft < 3 && ($sf == 1 || $imm <= 0x1f); }

# C3.5.3 Add/subtract (with carry)
# 31 30 29 28 27 26 25 24 23 22 21 |20    16 15         10 9    5 4    0
# sf op  S  1  1  0  1  0  0  0  0 |   Rm       opcode2      Rn     Rd

ADC A64 sf:1 00 11010000 rm:5 000000 rn:5 rd:5

SBC A64 sf:1 10 11010000 rm:5 000000 rn:5 rd:5

# C3.5.4 Conditional compare (immediate) - NIY

# C3.5.5 Conditional compare (register) - NIY

# C3.5.6 Conditional select
# 31 30 29 28 27 26 25 24 23 22 21 |20    16 15      12 11 10 9    5 4    0
# sf op  S  1  1  0  1  0  1  0  0 |   Rm       cond     op2    Rn     Rd

CSEL A64 sf:1 00 11010100 rm:5 cond:4 00 rn:5 rd:5

CSINC A64 sf:1 00 11010100 rm:5 cond:4 01 rn:5 rd:5

CSINV A64 sf:1 10 11010100 rm:5 cond:4 00 rn:5 rd:5

CSNEG A64 sf:1 10 11010100 rm:5 cond:4 01 rn:5 rd:5

# C3.5.7 Data-processing (1 source)
# 31 30 29 28 27 26 25 24 23 22 21 |20         16 15        10 9    5 4    0
# sf  1  S  1  1  0  1  0  1  1  0 |   opcode2       opcode      Rn     Rd

RBIT A64 sf:1 10 11010110 00000 000000 rn:5 rd:5

REV16 A64 sf:1 10 11010110 00000 000001 rn:5 rd:5

REV32 A64 sf:1 10 11010110 00000 000010 rn:5 rd:5

CLZ A64 sf:1 10 11010110 00000 000100 rn:5 rd:5

CLS A64 sf:1 10 11010110 00000 000101 rn:5 rd:5

REV64 A64 1 10 11010110 00000 000011 rn:5 rd:5

# C3.5.8 Data-processing (2 source)
# 31 30 29 28 27 26 25 24 23 22 21 |20    16 15        10 9    5 4    0
# sf  0  S  1  1  0  1  0  1  1  0 |   Rm       opcode      Rn     Rd

UDIV A64 sf:1 00 11010110 rm:5 000010 rn:5 rd:5
SDIV A64 sf:1 00 11010110 rm:5 000011 rn:5 rd:5
LSLV A64 sf:1 00 11010110 rm:5 001000 rn:5 rd:5
LSRV A64 sf:1 00 11010110 rm:5 001001 rn:5 rd:5
ASRV A64 sf:1 00 11010110 rm:5 001010 rn:5 rd:5
RORV A64 sf:1 00 11010110 rm:5 001011 rn:5 rd:5

# CRC32 availability is implementation-defined, commented out for now
#CRC32B A64 0 00 11010110 rm:5 010000 rn:5 rd:5
#CRC32H A64 0 00 11010110 rm:5 010001 rn:5 rd:5
#CRC32W A64 0 00 11010110 rm:5 010010 rn:5 rd:5
#CRC32CB A64 0 00 11010110 rm:5 010100 rn:5 rd:5
#CRC32CH A64 0 00 11010110 rm:5 010101 rn:5 rd:5
#CRC32CW A64 0 00 11010110 rm:5 010110 rn:5 rd:5
#CRC32X A64 1 00 11010110 rm:5 010011 rn:5 rd:5
#CRC32CX A64 1 00 11010110 rm:5 010111 rn:5 rd:5

# C3.5.9 Data-processing (3 source)
# 31 |30 29| 28 27 26 25 24 |23    21|20    16 15 14    10 9    5 4    0
# sf | op54|  1  1  0  1  1 |  op31  |   Rm    o0    Ra      Rn     Rd

MADD A64 sf:1 00 11011 000 rm:5 0 ra:5 rn:5 rd:5 \
!constraints { $ra != 31; }

MUL A64 sf:1 00 11011 000 rm:5 0 11111 rn:5 rd:5

MSUB A64 sf:1 00 11011 000 rm:5 1 ra:5 rn:5 rd:5 \
!constraints { $ra != 31; }

MNEG A64 sf:1 00 11011 000 rm:5 1 11111 rn:5 rd:5

SMADDL A64 1 00 11011 001 rm:5 0 ra:5 rn:5 rd:5 \
!constraints { $ra != 31; }

SMULL A64 1 00 11011 001 rm:5 0 11111 rn:5 rd:5

SMSUBL A64 1 00 11011 001 rm:5 1 ra:5 rn:5 rd:5 \
!constraints { $ra != 31; }

SMNEGL A64 1 00 11011 001 rm:5 1 11111 rn:5 rd:5

SMULH A64 1 00 11011 010 rm:5 0 ra:5 rn:5 rd:5

UMADDL A64 1 00 11011 101 rm:5 0 ra:5 rn:5 rd:5 \
!constraints { $ra != 31; }

UMULL A64 1 00 11011 101 rm:5 0 11111 rn:5 rd:5

UMSUBL A64 1 00 11011 101 rm:5 1 ra:5 rn:5 rd:5 \
!constraints { $ra != 31; }

UMNEGL A64 1 00 11011 101 rm:5 1 11111 rn:5 rd:5

UMULH A64 1 00 11011 110 rm:5 0 ra:5 rn:5 rd:5

# C3.5.10 Logical (shifted register)
# 31|30 29| 28 27 26 25 24 |23 22| 21| 20    16 15      10 9    5 4    0
# sf| opc |  0  1  0  1  0 |shift|  N|    Rm       imm6      Rn     Rd

AND A64 sf:1 00 01010 shft:2 0 rm:5 imm:6 rn:5 rd:5 \
!constraints { $sf == 1 || $imm <= 0x1f; }

BIC A64 sf:1 00 01010 shft:2 1 rm:5 imm:6 rn:5 rd:5 \
!constraints { $sf == 1 || $imm <= 0x1f; }

ORR A64 sf:1 01 01010 shft:2 0 rm:5 imm:6 rn:5 rd:5 \
!constraints { $sf == 1 || $imm <= 0x1f; }

ORN A64 sf:1 01 01010 shft:2 1 rm:5 imm:6 rn:5 rd:5 \
!constraints { $rn != 31 && ($sf == 1 || $imm <= 0x1f); }

MVN A64 sf:1 01 01010 shft:2 1 rm:5 imm:6 11111 rd:5 \
!constraints { $sf == 1 || $imm <= 0x1f; }

EOR A64 sf:1 10 01010 shft:2 0 rm:5 imm:6 rn:5 rd:5 \
!constraints { $sf == 1 || $imm <= 0x1f; }

EON A64 sf:1 10 01010 shft:2 1 rm:5 imm:6 rn:5 rd:5 \
!constraints { $sf == 1 || $imm <= 0x1f; }
