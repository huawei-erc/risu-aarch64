###############################################################################
# Copyright (c) 2010 Linaro Limited
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the Eclipse Public License v1.0
# which accompanies this distribution, and is available at
# http://www.eclipse.org/legal/epl-v10.html
#
# Contributors:
#     Claudio Fontana - initial implementation
#     based on arm.risu by Peter Maydell
###############################################################################

# Input file for risugen defining AArch64 instructions
.mode aarch64

# from ARM DDI 0487A.a ARM Architecture Reference Manual
# XXX NIY: branch, exception generation, system insns
# XXX NIY: PC-related instructions
# XXX NIY: SP-related instructions
# XXX NIY: floating point and SIMD specific insns

# - - - - 1 - 0 - - - - - - - - - - - - - - - Loads and stores
# C3.3 Loads and stores

# C3.3.1 AdvSIMD load/store multiple structures
# C3.3.2 AdvSIMD load/store multiple structures (post-indexed)
# C3.3.3 AdvSIMD load/store single structure
# C3.3.4 AdvSIMD load/store single structure (post-indexed)
#
# C6.3.275 ST1 (multiple structures) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  0  0  0  0  0  0  0  0  x  x  1  x size   Rn   Rt
#                            [L]                  [  opcode  ]

ST1m_1 A64_V 0 Q:1 001100000 00000 0111 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1 << $size); reg($rn); }

ST1m_2 A64_V 0 Q:1 001100000 00000 1010 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1 << $size); reg($rn); }

ST1m_3 A64_V 0 Q:1 001100000 00000 0110 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1 << $size); reg($rn); }

ST1m_4 A64_V 0 Q:1 001100000 00000 0010 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1 << $size); reg($rn); }

# Post-index (reg/immediate)
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  1  0  0    Rm     x  x  1  x  size  Rn   Rt
#                            [L]            [  opcode  ]

ST1m_1p A64_V 0 Q:1 001100100 rm:5 0111 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1 << $size); reg($rn); }

ST1m_2p A64_V 0 Q:1 001100100 rm:5 1010 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1 << $size); reg($rn); }

ST1m_3p A64_V 0 Q:1 001100100 rm:5 0110 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1 << $size); reg($rn); }

ST1m_4p A64_V 0 Q:1 001100100 rm:5 0010 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1 << $size); reg($rn); }

# C6.3.276 ST1 (single structure) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  0  0  0  0  0  0  0  0  x  x  0  S  size  Rn   Rt
#                            [L][R]               [  opc  ]
#              8-bit variant (opcode = 000)
#    ST1 { <Vt>.B }[<index>], [<Xn|SP>]
#              16-bit variant (opcode = 010, size = x0)
#    ST1 { <Vt>.H }[<index>], [<Xn|SP>]
#              32-bit variant (opcode = 100, size = 00)
#    ST1 { <Vt>.S }[<index>], [<Xn|SP>]
#              64-bit variant (opcode = 100, S = 0, size = 01)
#    ST1 { <Vt>.D }[<index>], [<Xn|SP>]

ST1_B A64_V 0 Q:1 001101000 00000 000 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1); reg($rn); }

ST1_H A64_V 0 Q:1 001101000 00000 010 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && !($size & 0x01); } \
!memory { align(2); reg($rn); }

ST1_S A64_V 0 Q:1 001101000 00000 100 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(4); reg($rn); }

ST1_D A64_V 0 Q:1 001101000 00000 100 0 01 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(8); reg($rn); }

# Post-index (reg/immediate)
#  31 30 29 28 27 26 25 24 23 22 21 20    16 15 14 13 12 11 10 9  5 4  0
#   0  Q  0  0  1  1  0  1  1  0  0    Rm     x  x  0  S size   Rn   Rt
#                             [L][R]          opcode

ST1_Bp A64_V 0 Q:1 001101100 rm:5 000 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1); reg($rn); }

ST1_Hp A64_V 0 Q:1 001101100 rm:5 010 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm && !($size & 0x01); } \
!memory { align(2); reg($rn); }

ST1_Sp A64_V 0 Q:1 001101100 rm:5 100 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(4); reg($rn); }

ST1_Dp A64_V 0 Q:1 001101100 rm:5 100 0 01 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(8); reg($rn); }

# C6.3.277 ST2 (multiple structures) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  0  0  0  0  0  0  0  0  1  0  0  0  size  Rn   Rt
#                            [L]                  [  opcode  ]

ST2m A64_V 0 Q:1 001100000 00000 1000 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && !($size == 3 && $Q == 0); } \
!memory { align(1 << $size); reg($rn); }

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20          16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  1  0  0       Rm        1  0  0  0  size  Rn   Rt
#                            [L]                  [  opcode  ]

ST2m_p A64_V 0 Q:1 001100100 rm:5 1000 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm && !($size == 3 && $Q == 0); } \
!memory { align(1 << $size); reg($rn); }

# C6.3.278 ST2 (single structure) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  0  0  1  0  0  0  0  0  x  x  0  S  size  Rn   Rt
#                            [L][R]               [  opc  ]

ST2_B A64_V 0 Q:1 001101001 00000 000 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1); reg($rn); }

ST2_H A64_V 0 Q:1 001101001 00000 010 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && !($size & 0x01); } \
!memory { align(2); reg($rn); }

ST2_S A64_V 0 Q:1 001101001 00000 100 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(4); reg($rn); }

ST2_D A64_V 0 Q:1 001101001 00000 100 0 01 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(8); reg($rn); }

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  1  0  1    Rm     x  x  0  S  size  Rn   Rt
#                            [L][R]         [  opc  ]

ST2_Bp A64_V 0 Q:1 001101101 rm:5 000 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1); reg($rn); }

ST2_Hp A64_V 0 Q:1 001101101 rm:5 010 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm && !($size & 0x01); } \
!memory { align(2); reg($rn); }

ST2_Sp A64_V 0 Q:1 001101101 rm:5 100 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(4); reg($rn); }

ST2_Dp A64_V 0 Q:1 001101101 rm:5 100 0 01 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(8); reg($rn); }

# C6.3.279 ST3 (multiple structures) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  0  0  0  0  0  0  0  0  0  1  0  0  size  Rn   Rt
#                            [L]                  [  opcode  ]
ST3m A64_V 0 Q:1 001100000 00000 0100 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && !($size == 3 && $Q == 0); } \
!memory { align(1 << $size); reg($rn); }

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20          16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  1  0  0       Rm        0  1  0  0  size  Rn   Rt
#                            [L]                  [  opcode  ]

ST3m_p A64_V 0 Q:1 001100100 rm:5 0100 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rm != $rn && !($size == 3 && $Q == 0); } \
!memory { align(1 << $size); reg($rn); }

# C6.3.280 ST3 (single structure) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  0  0  0  0  0  0  0  0  x  x  1  S  size  Rn   Rt
#                            [L][R]               [  opc  ]

ST3_B A64_V 0 Q:1 001101000 00000 001 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1); reg($rn); }

ST3_H A64_V 0 Q:1 001101000 00000 011 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && !($size & 0x01); } \
!memory { align(2); reg($rn); }

ST3_S A64_V 0 Q:1 001101000 00000 101 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(4); reg($rn); }

ST3_D A64_V 0 Q:1 001101000 00000 101 0 01 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(8); reg($rn); }

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  1  0  0    Rm     x  x  1  S  size  Rn   Rt
#                            [L][R]         [  opc  ]

ST3_Bp A64_V 0 Q:1 001101100 rm:5 001 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1); reg($rn); }

ST3_Hp A64_V 0 Q:1 001101100 rm:5 011 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm && !($size & 0x01); } \
!memory { align(2); reg($rn); }

ST3_Sp A64_V 0 Q:1 001101100 rm:5 101 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(4); reg($rn); }

ST3_Dp A64_V 0 Q:1 001101100 rm:5 101 0 01 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(8); reg($rn); }

# C6.3.281 ST4 (multiple structures) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  size  Rn   Rt
#                            [L]                  [  opcode  ]

ST4m A64_V 0 Q:1 001100000 00000 0000 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && !($size == 3 && $Q == 0); } \
!memory { align(1 << $size); reg($rn); }

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20  16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  1  0  0   Rm    0  0  0  0  size  Rn   Rt
#                            [L]          [  opcode  ]

ST4m_p A64_V 0 Q:1 001100100 rm:5 0000 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rm != $rn && !($size == 3 && $Q == 0); } \
!memory { align(1 << $size); reg($rn); }

# C6.3.282 ST4 (single structure) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  0  0  1  0  0  0  0  0  x  x  1  S  size  Rn   Rt
#                            [L][R]               [  opc  ]

ST4_B A64_V 0 Q:1 001101001 00000 001 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1); reg($rn); }

ST4_H A64_V 0 Q:1 001101001 00000 011 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && !($size & 0x01); } \
!memory { align(2); reg($rn); }

ST4_S A64_V 0 Q:1 001101001 00000 101 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(4); reg($rn); }

ST4_D A64_V 0 Q:1 001101001 00000 101 0 01 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(8); reg($rn); }

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  1  0  1    Rm     x  x  1  S  size  Rn   Rt
#                            [L][R]         [  opc  ]

ST4_Bp A64_V 0 Q:1 001101101 rm:5 001 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1); reg($rn); }

ST4_Hp A64_V 0 Q:1 001101101 rm:5 011 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm && !($size & 0x01); } \
!memory { align(2); reg($rn); }

ST4_Sp A64_V 0 Q:1 001101101 rm:5 101 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(4); reg($rn); }

ST4_Dp A64_V 0 Q:1 001101101 rm:5 101 0 01 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(8); reg($rn); }


# C6.3.152 LD1 (multiple structures) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  0  1  0  0  0  0  0  0  x  x  1  x  size  Rn   Rt
#                            [L]                  [  opcode  ]

LD1m_1 A64_V 0 Q:1 001100010 00000 0111 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1 << $size); reg($rn); }

LD1m_2 A64_V 0 Q:1 001100010 00000 1010 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1 << $size); reg($rn); }

LD1m_3 A64_V 0 Q:1 001100010 00000 0110 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1 << $size); reg($rn); }

LD1m_4 A64_V 0 Q:1 001100010 00000 0010 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1 << $size); reg($rn); }

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  1  1  0    Rm     x  x  1  x  size  Rn   Rt
#                            [L]            [  opcode  ]

LD1m_1p A64_V 0 Q:1 001100110 rm:5 0111 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1 << $size); reg($rn); }

LD1m_2p A64_V 0 Q:1 001100110 rm:5 1010 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1 << $size); reg($rn); }

LD1m_3p A64_V 0 Q:1 001100110 rm:5 0110 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1 << $size); reg($rn); }

LD1m_4p A64_V 0 Q:1 001100110 rm:5 0010 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1 << $size); reg($rn); }

# C6.3.153 LD1 (single structure) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  0  1  0  0  0  0  0  0  x  x  0  S  size  Rn   Rt
#                            [L][R]               [  opc  ]

LD1_B A64_V 0 Q:1 001101010 00000 000 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1); reg($rn); }

LD1_H A64_V 0 Q:1 001101010 00000 010 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && !($size & 0x01); } \
!memory { align(2); reg($rn); }

LD1_S A64_V 0 Q:1 001101010 00000 100 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(4); reg($rn); }

LD1_D A64_V 0 Q:1 001101010 00000 100 0 01 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(8); reg($rn); }

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  1  1  0    Rm     x  x  0  S  size  Rn   Rt
#                            [L][R]         [  opc  ]

LD1_Bp A64_V 0 Q:1 001101110 rm:5 000 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1); reg($rn); }

LD1_Hp A64_V 0 Q:1 001101110 rm:5 010 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm && !($size & 0x01); } \
!memory { align(2); reg($rn); }

LD1_Sp A64_V 0 Q:1 001101110 rm:5 100 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(4); reg($rn); }

LD1_Dp A64_V 0 Q:1 001101110 rm:5 100 0 01 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(8); reg($rn); }


# C6.3.154 LD1R - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  0  1  0  0  0  0  0  0  1  1  0  0  size  Rn   Rt
#                            [L][R]               [  opc  ][S]

LD1R A64_V 0 Q:1 001101010 00000 110 0 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1 << $size); reg($rn); }

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20  16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  1  1  0   Rm    1  1  0  0  size  Rn   Rt
#                            [L][R]       [  opc  ][S]

LD1R_p A64_V 0 Q:1 001101110 rm:5 110 0 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1 << $size); reg($rn); }

# C6.3.155 LD2 (multiple structures) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  0  1  0  0  0  0  0  0  1  0  0  0  size  Rn   Rt
#                            [L]                  [  opcode  ]

LD2m A64_V 0 Q:1 001100010 00000 1000 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && !($size == 3 && $Q == 0); } \
!memory { align(1 << $size); reg($rn); }

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20  16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  1  1  0   Rm    1  0  0  0  size  Rn   Rt
#                            [L]          [  opcode  ]

LD2m_p A64_V 0 Q:1 001100110 rm:5 1000 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm && !($size == 3 && $Q == 0); } \
!memory { align(1 << $size); reg($rn); }

# C6.3.156 LD2 (single structure) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  0  1  1  0  0  0  0  0  x  x  0  S  size  Rn   Rt
#                            [L][R]               [  opc  ]

LD2_B A64_V 0 Q:1 001101011 00000 000 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1); reg($rn); }

LD2_H A64_V 0 Q:1 001101011 00000 010 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && !($size & 0x01); } \
!memory { align(2); reg($rn); }

LD2_S A64_V 0 Q:1 001101011 00000 100 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(4); reg($rn); }

LD2_D A64_V 0 Q:1 001101011 00000 100 0 01 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(8); reg($rn); }

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20  16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  1  1  1   Rm    x  x  0  S  size  Rn   Rt
#                            [L][R]       [  opc  ]

LD2_Bp A64_V 0 Q:1 001101111 rm:5 000 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1); reg($rn); }

LD2_Hp A64_V 0 Q:1 001101111 rm:5 010 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm && !($size & 0x01); } \
!memory { align(2); reg($rn); }

LD2_Sp A64_V 0 Q:1 001101111 rm:5 100 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(4); reg($rn); }

LD2_Dp A64_V 0 Q:1 001101111 rm:5 100 0 01 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(8); reg($rn); }

# C6.3.157 LD2R - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  0  1  1  0  0  0  0  0  1  1  0  0  size  Rn   Rt
#                            [L][R]               [  opc  ] S

LD2R A64_V 0 Q:1 001101011 00000 110 0 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1 << $size); reg($rn); }

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  1  1  1    Rm     1  1  0  0  size  Rn   Rt
#                            [L][R]         [  opc  ] S

LD2R_p A64_V 0 Q:1 001101111 rm:5 110 0 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1 << $size); reg($rn); }

# C6.3.158 LD3 (multiple structures) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  0  1  0  0  0  0  0  0  0  1  0  0  size  Rn   Rt
#                            [L]                  [  opcode  ]

LD3m A64_V 0 Q:1 001100010 00000 0100 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && !($size == 3 && $Q == 0); } \
!memory { align(1 << $size); reg($rn); }

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  1  1  0    Rm     0  1  0  0  size  Rn   Rt
#                            [L]            [  opcode  ]

LD3m_p A64_V 0 Q:1 001100110 rm:5 0100 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm && !($size == 3 && $Q == 0); } \
!memory { align(1 << $size); reg($rn); }

# C6.3.159 LD3 (single structure) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  0  1  0  0  0  0  0  0  x  x  1  S  size  Rn   Rt
#                            [L][R]               [  opc  ]

LD3_B A64_V 0 Q:1 001101010 00000 001 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1); reg($rn); }

LD3_H A64_V 0 Q:1 001101010 00000 011 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && !($size & 0x01); } \
!memory { align(2); reg($rn); }

LD3_S A64_V 0 Q:1 001101010 00000 101 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(4); reg($rn); }

LD3_D A64_V 0 Q:1 001101010 00000 101 0 01 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(8); reg($rn); }

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  1  1  0    Rm     x  x  1  S  size  Rn   Rt
#                            [L][R]         [  opc  ]

LD3_Bp A64_V 0 Q:1 001101110 rm:5 001 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1); reg($rn); }

LD3_Hp A64_V 0 Q:1 001101110 rm:5 011 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm && !($size & 0x01); } \
!memory { align(2); reg($rn); }

LD3_Sp A64_V 0 Q:1 001101110 rm:5 101 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(4); reg($rn); }

LD3_Dp A64_V 0 Q:1 001101110 rm:5 101 0 01 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(8); reg($rn); }

# C6.3.160 LD3R - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  0  1  0  0  0  0  0  0  1  1  1  0  size  Rn   Rt
#                            [L][R]               [  opc  ] S

LD3R A64_V 0 Q:1 001101010 00000 111 0 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1 << $size); reg($rn); }

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  1  1  0    Rm     1  1  1  0  size  Rn   Rt
#                            [L][R]         [  opc  ] S

LD3R_p A64_V 0 Q:1 001101110 rm:5 111 0 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1 << $size); reg($rn); }

# C6.3.161 LD4 (multiple structures) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  0  1  0  0  0  0  0  0  0  0  0  0  size  Rn   Rt
#                            [L]                  [  opcode  ]

LD4m A64_V 0 Q:1 001100010 00000 0000 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && !($size == 3 && $Q == 0); } \
!memory { align(1 << $size); reg($rn); }

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  0  1  1  0    Rm     0  0  0  0  size  Rn   Rt
#                            [L]            [  opcode  ]

LD4m_p A64_V 0 Q:1 001100110 rm:5 0000 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm && !($size == 3 && $Q == 0); } \
!memory { align(1 << $size); reg($rn); }

# C6.3.162 LD4 (single structure) - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  0  1  1  0  0  0  0  0  x  x  1  S  size  Rn   Rt
#                            [L][R]               [  opc  ]

LD4_B A64_V 0 Q:1 001101011 00000 001 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1); reg($rn); }

LD4_H A64_V 0 Q:1 001101011 00000 011 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && !($size & 0x01); } \
!memory { align(2); reg($rn); }

LD4_S A64_V 0 Q:1 001101011 00000 101 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(4); reg($rn); }

LD4_D A64_V 0 Q:1 001101011 00000 101 0 01 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(8); reg($rn); }

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  1  1  1    Rm     x  x  1  S  size  Rn   Rt
#                            [L][R]         [  opc  ]

LD4_Bp A64_V 0 Q:1 001101111 rm:5 001 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1); reg($rn); }

LD4_Hp A64_V 0 Q:1 001101111 rm:5 011 S:1 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm && !($size & 0x01); } \
!memory { align(2); reg($rn); }

LD4_Sp A64_V 0 Q:1 001101111 rm:5 101 S:1 00 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(4); reg($rn); }

LD4_Dp A64_V 0 Q:1 001101111 rm:5 101 0 01 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(8); reg($rn); }

# C6.3.163 LD4R - no offset
# 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  0  1  1  0  0  0  0  0  1  1  1  0  size  Rn   Rt
#                            [L][R]               [  opc  ] S

LD4R A64_V 0 Q:1 001101011 00000 111 0 size:2 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1 << $size); reg($rn); }

# Post-index
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15 14 13 12 11 10 9  5 4  0
#  0  Q  0  0  1  1  0  1  1  1  1    Rm     1  1  1  0  size  Rn   Rt
#                            [L][R]         [  opc  ] S

LD4R_p A64_V 0 Q:1 001101111 rm:5 111 0 size:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1 << $size); reg($rn); }

# C3.3.5 Load register (PC-relative literal)
# 31 30 29 28 27 26 25 24 23       5 4    0
#  opc   0  1  1  V  0  0    imm19     Rt
#
# XXX claudio NIY: problematic, as we need to reach the memblock
# as a PC-relative immediate offset, and check the
# constraints (whether it fits in immx).
#
# LDR_L A64 opc:2 0110 00 imm:19 rt:5 \
# !constraints { $opc != 0x3; } \
# !memory { pc_adr(); }
# PRFM_L A64 11 0 110 00 imm:19 rt:5

# C3.3.6 Load/store exclusive
# 31 30 29 28 27 26 25 24 23 22 21 20    16 15 14     10 9    5 4    0
#  size  0  0  1  0  0  0 o2  L o1    Rs    o0    Rt2      Rn     Rt

# size o2 L o1 o0
#  00   0  0 0  0  STXRB            -
#  00   0  0 0  1  STLXRB           -
#  00   1  0 0  1  STLRB            -

#  01   0  0 0  0  STXRH            -
#  01   0  0 0  1  STLXRH           -
#  01   1  0 0  1  STLRH            -

#  00   0  1 0  0  LDXRB            -
#  00   0  1 0  1  LDAXRB           -
#  00   1  1 0  1  LDARB            -

#  01   0  1 0  0  LDXRH            -
#  01   0  1 0  1  LDAXRH           -
#  01   1  1 0  1  LDARH            -

#  10   0  0 0  0  STXR        32-bit
#  10   0  0 0  1  STLXR       32-bit
#  10   1  0 0  1  STLR        32-bit

#  10   0  1 0  0  LDXR        32-bit
#  10   0  1 0  1  LDAXR       32-bit
#  10   1  1 0  1  LDAR        32-bit

#  11   0  0 0  0  STXR        64-bit
#  11   0  0 0  1  STLXR       64-bit
#  11   1  0 0  1  STLR        64-bit

#  11   0  1 0  0  LDXR        64-bit
#  11   0  1 0  1  LDAXR       64-bit
#  11   1  1 0  1  LDAR        64-bit

# data is in rt, base address in rn, status written to rs

# XXX note: the rn != rt, rn != rtt constraint is a limitation
# of risu. If rn = rt, the SUB used to normalize the base to a non
# process-dependent value is going to have the opposite effect to
# change the load result to a process-dependent value.
# The Tech. Ref. Manual defines behavior for rn == rt in some
# cases (not with writeback, ... etc), so at some point we should
# find out how to relax some of these constraints to really check
# the whole range of possibilities.

STXRB A64 00 001000 000 rs:5 0 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rn && $rn != $rt; } \
!memory { align(1); reg($rn); }

STLXRB A64 00 001000 000 rs:5 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rn && $rn != $rt; } \
!memory { align(1); reg($rn); }

STLRB A64 00 001000 100 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(1); reg($rn); }

STXRH A64 01 001000 000 rs:5 0 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rn && $rn != $rt; } \
!memory { align(2); reg($rn); }

STLXRH A64 01 001000 000 rs:5 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rn && $rn != $rt; } \
!memory { align(2); reg($rn); }

STLRH A64 01 001000 100 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(2); reg($rn); }

LDXRB A64 00 001000 010 11111 0 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(1); reg($rn); }

LDAXRB A64 00 001000 010 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(1); reg($rn); }

LDARB A64 00 001000 110 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(1); reg($rn); }

LDXRH A64 01 001000 010 11111 0 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(2); reg($rn); }

LDAXRH A64 01 001000 010 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(2); reg($rn); }

LDARH A64 01 001000 110 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(2); reg($rn); }

STXRW A64 10 001000 000 rs:5 0 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rn && $rn != $rt; } \
!memory { align(4); reg($rn); }

STLXRW A64 10 001000 000 rs:5 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rn && $rn != $rt; } \
!memory { align(4); reg($rn); }

STLRW A64 10 001000 100 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(4); reg($rn); }

LDXRW A64 10 001000 010 11111 0 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(4); reg($rn); }

LDAXRW A64 10 001000 010 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(4); reg($rn); }

LDARW A64 10 001000 110 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(4); reg($rn); }

STXR A64 11 001000 000 rs:5 0 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rn && $rn != $rt; } \
!memory { align(8); reg($rn); }

STLXR A64 11 001000 000 rs:5 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rn && $rn != $rt; } \
!memory { align(8); reg($rn); }

STLR A64 11 001000 100 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(8); reg($rn); }

LDXR A64 11 001000 010 11111 0 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(8); reg($rn); }

LDAXR A64 11 001000 010 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(8); reg($rn); }

LDAR A64 11 001000 110 11111 1 11111 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(8); reg($rn); }

#  Now with P (pair load/stores):
#  10   0  0 1  0  STXP        32-bit
#  10   0  0 1  1  STLXP       32-bit

#  10   0  1 1  0  LDXP        32-bit
#  10   0  1 1  1  LDAXP       32-bit

#  11   0  0 1  0  STXP        64-bit
#  11   0  0 1  1  STLXP       64-bit

#  11   0  1 1  0  LDXP        64-bit
#  11   0  1 1  1  LDAXP       64-bit

STXPW A64 10 001000 001 rs:5 0 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rtt && $rs != $rn && $rn != $rt && $rn != $rtt; } \
!memory { align(8); reg($rn); }

STLXPW A64 10 001000 001 rs:5 1 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rtt && $rs != $rn && $rn != $rt && $rn != $rtt; } \
!memory { align(8); reg($rn); }

LDXPW A64 10 001000 011 11111 0 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt && $rn != $rt && $rn != $rtt; } \
!memory { align(8); reg($rn); }

LDAXPW A64 10 001000 011 11111 1 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt && $rn != $rt && $rn != $rtt; } \
!memory { align(8); reg($rn); }

STXP A64 11 001000 001 rs:5 0 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rtt && $rs != $rn && $rn != $rt && $rn != $rtt; } \
!memory { align(16); reg($rn); }

STLXP A64 11 001000 001 rs:5 1 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rs != $rt && $rs != $rtt && $rs != $rn && $rn != $rt && $rn != $rtt; } \
!memory { align(16); reg($rn); }

LDXP A64 11 001000 011 11111 0 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt && $rn != $rt && $rn != $rtt; } \
!memory { align(16); reg($rn); }

LDAXP A64 11 001000 011 11111 1 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt && $rn != $rt && $rn != $rtt; } \
!memory { align(16); reg($rn); }

# C3.3.7 Load/store no-allocate pair (offset)
# 31 30 29 28 27 26 25 24 23 22 21      15 14     10 9    5 4    0
#  opc   1  0  1  V  0  0  0  L    simm7      Rt2      Rn     Rt
#
#  opc            V           L
#   00            0           0    STNP 32-bit
#   00            0           1    LDNP 32-bit
#   10            0           0    STNP 64-bit
#   10            0           1    LDNP 64-bit

STNPW A64 00 101 0 000 0 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rn != $rtt; } \
!memory { align(8); reg_plus_imm($rn, sextract($imm, 7) * 4); }

LDNPW A64 00 101 0 000 1 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt && $rn != $rt && $rn != $rtt; } \
!memory { align(8); reg_plus_imm($rn, sextract($imm, 7) * 4); }

STNP A64 10 101 0 000 0 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rn != $rtt; } \
!memory { align(16); reg_plus_imm($rn, sextract($imm, 7) * 8); }

LDNP A64 10 101 0 000 1 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt && $rn != $rt && $rn != $rtt; } \
!memory { align(16); reg_plus_imm($rn, sextract($imm, 7) * 8); }

# SIMD variants
#  opc            V           L
#   00            1           0    SIMD STNP  32-bit
#   00            1           1    SIMD LDNP  32-bit
#   01            1           0    SIMD STNP  64-bit
#   01            1           1    SIMD LDNP  64-bit
#   10            1           0    SIMD STNP 128-bit
#   10            1           1    SIMD LDNP 128-bit

# C6.3.283 STNP (SIMD&FP) C6.3.164 LDNP (SIMD&FP)
# 31 30 29 28 27 26 25 24 23 22 21    15 14    10 9    5 4    0
#  opc   1  0  1  1  0  0  0  L   imm7     Rt2      Rn     Rt

STNPS A64_V 00 10110000 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(8); reg_plus_imm($rn, sextract($imm, 7) * 4); }

LDNPS A64_V 00 10110001 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt; } \
!memory { align(8); reg_plus_imm($rn, sextract($imm, 7) * 4); }

STNPD A64_V 01 10110000 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(16); reg_plus_imm($rn, sextract($imm, 7) * 8); }

LDNPD A64_V 01 10110001 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt; } \
!memory { align(16); reg_plus_imm($rn, sextract($imm, 7) * 8); }

STNPQ A64_V 10 10110000 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(32); reg_plus_imm($rn, sextract($imm, 7) * 16); }

LDNPQ A64_V 10 10110001 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt; } \
!memory { align(32); reg_plus_imm($rn, sextract($imm, 7) * 16); }

# C3.3.8 Load/store register (immediate post-indexed)
# 31 30 29 28 27 26 25 24 23 22 21 20      12 11 10 9    5 4    0
#  size  1  1  1  V  0  0  opc   0    imm9     0  1   Rn     Rt
# merged with 3.3.12

# C3.3.9 Load/store register (immediate pre-indexed)
# 31 30 29 28 27 26 25 24 23 22 21 20      12 11 10 9    5 4    0
#  size  1  1  1  V  0  0  opc   0    imm9     1  1   Rn     Rt
# merged with 3.3.12

# C3.3.10 Load/store register (register offset)
# 31 30 29 28 27 26 25 24 23 22 21 20      16 15     13 12 11 10 9    5 4        0
#  size  1  1  1  V  0  0  opc   1     Rm      option    S  1  0   Rn       Rt
#
#   00            0         00     STRB (register)  -
#   00            0         01     LDRB (register)  -
#   00            0         10     LDRSB (register) 64-bit
#   00            0         11     LDRSB (register) 32-bit
#   01            0         00     STRH (register)  -
#   01            0         01     LDRH (register)  -
#   01            0         10     LDRSH (register) 64-bit
#   01            0         11     LDRSH (register) 32-bit
#   10            0         00     STR (register)   32-bit
#   10            0         01     LDR (register)   32-bit
#   10            0         10     LDRSW (register) -
#   11            0         00     STR (register)   64-bit
#   11            0         01     LDR (register)   64-bit
#   11            0         10     PRFM (register)  -

# XXX opt=011 for now (LSL), other options NIY.
# XXX the constraint rn != rm is our limitation, not imposed by arch.
STRBr A64 00 111000 00 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rm != $rt && $rn != $rm; } \
!memory { align(1); reg_plus_reg_shifted($rn, $rm, $shft ? 0 : 0); }

LDRBr A64 00 111000 01 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rm != $rt && $rn != $rm; } \
!memory { align(1); reg_plus_reg_shifted($rn, $rm, $shft ? 0 : 0); }

LDRSBr A64 00 111000 10 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rm != $rt && $rn != $rm; } \
!memory { align(1); reg_plus_reg_shifted($rn, $rm, $shft ? 0 : 0); }

LDRSBWr A64 00 111000 11 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rm != $rt && $rn != $rm; } \
!memory { align(1); reg_plus_reg_shifted($rn, $rm, $shft ? 0 : 0); }

STRHr A64 01 111000 00 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rm != $rt && $rn != $rm; } \
!memory { align(2); reg_plus_reg_shifted($rn, $rm, $shft ? 1 : 0); }

LDRHr A64 01 111000 01 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rm != $rt && $rn != $rm; } \
!memory { align(2); reg_plus_reg_shifted($rn, $rm, $shft ? 1 : 0); }

LDRSHr A64 01 111000 10 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rm != $rt && $rn != $rm; } \
!memory { align(2); reg_plus_reg_shifted($rn, $rm, $shft ? 1 : 0); }

LDRSHWr A64 01 111000 11 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rm != $rt && $rn != $rm; } \
!memory { align(2); reg_plus_reg_shifted($rn, $rm, $shft ? 1 : 0); }

STRWr A64 10 111000 00 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rm != $rt && $rn != $rm; } \
!memory { align(4); reg_plus_reg_shifted($rn, $rm, $shft ? 2 : 0); }

LDRWr A64 10 111000 01 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rm != $rt && $rn != $rm; } \
!memory { align(4); reg_plus_reg_shifted($rn, $rm, $shft ? 2 : 0); }

LDRSWr A64 10 111000 10 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rm != $rt && $rn != $rm; } \
!memory { align(4); reg_plus_reg_shifted($rn, $rm, $shft ? 2 : 0); }

STRr A64 11 111000 00 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rm != $rt && $rn != $rm; } \
!memory { align(8); reg_plus_reg_shifted($rn, $rm, $shft ? 3 : 0); }

LDRr A64 11 111000 01 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rm != $rt && $rn != $rm; } \
!memory { align(8); reg_plus_reg_shifted($rn, $rm, $shft ? 3 : 0); }

PRFMr A64 11 111000 10 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rm != $rt && $rn != $rm; } \
!memory { align(8); reg_plus_reg_shifted($rn, $rm, $shft ? 3 : 0); }

# C6.3.286 STR (register, SIMD&FP) (register offset)
# 31 30 29 28 27 26 25 24 23 22 21 20       16 15    13 12 11 10 9  5 4  0
#  size  1  1  1  1  0  0  x  0  1     Rm       option   S  1  0  Rn   Rt
#                [V]      [ opc ]
#   00            1         00     SIMD STR (register)  8bit
#   00            1         01     SIMD LDR (register)  8bit
#   01            1         00     SIMD STR (register)  16bit
#   01            1         01     SIMD LDR (register)  16bit
#   10            1         00     SIMD STR (register)  32bit
#   10            1         01     SIMD LDR (register)  32bit
#   11            1         00     SIMD STR (register)  64bit
#   11            1         01     SIMD LDR (register)  64bit
#   00            1         10     SIMD STR (register) 128bit
#   00            1         11     SIMD LDR (register) 128bit
#
# XXX NIY: only LSL option=011 implemented

STRBr A64_V 00 111100 00 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1); reg_plus_reg_shifted($rn, $rm, $shft ? 0 : 0); }

LDRBr A64_V 00 111100 01 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(1); reg_plus_reg_shifted($rn, $rm, $shft ? 0 : 0); }

STRHr A64_V 01 111100 00 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(2); reg_plus_reg_shifted($rn, $rm, $shft ? 1 : 0); }

LDRHr A64_V 01 111100 01 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(2); reg_plus_reg_shifted($rn, $rm, $shft ? 1 : 0); }

STRSr A64_V 10 111100 00 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(4); reg_plus_reg_shifted($rn, $rm, $shft ? 2 : 0); }

LDRSr A64_V 10 111100 01 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(4); reg_plus_reg_shifted($rn, $rm, $shft ? 2 : 0); }

STRDr A64_V 11 111100 00 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(8); reg_plus_reg_shifted($rn, $rm, $shft ? 3 : 0); }

LDRDr A64_V 11 111100 01 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(8); reg_plus_reg_shifted($rn, $rm, $shft ? 3 : 0); }

STRQr A64_V 00 111100 10 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(16); reg_plus_reg_shifted($rn, $rm, $shft ? 4 : 0); }

LDRQr A64_V 00 111100 11 1 rm:5 011 shft:1 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rm; } \
!memory { align(16); reg_plus_reg_shifted($rn, $rm, $shft ? 4 : 0); }

# C3.3.11 Load/store register (unprivileged)
# 31 30 29 28 27 26 25 24 23 22 21 20      12 11 10 9    5 4        0
#  size  1  1  1  V  0  0  opc   0    imm9     1  0   Rn       Rt
#
#  size           V        opc
#   00            0         00      STTRB   -
#   00            0         01      LDTRB   -
#   00            0         10      LDTRSB  64-bit
#   00            0         11      LDTRSB  32-bit
#   01            0         00      STTRH   -
#   01            0         01      LDTRH   -
#   01            0         10      LDTRSH  64-bit
#   01            0         11      LDTRSH  32-bit
#   10            0         00      STTR    32-bit
#   10            0         01      LDTR    32-bit
#   10            0         10      LDTRSW  -
#   11            0         00      STTR    64-bit
#   11            0         01      LDTR    64-bit

STTRB A64 00 111000 00 0 imm:9 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(1); reg_plus_imm($rn, sextract($imm, 9)); }

LDTRB A64 00 111000 01 0 imm:9 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(1); reg_plus_imm($rn, sextract($imm, 9)); }

LDTRSB A64 00 111000 10 0 imm:9 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(1); reg_plus_imm($rn, sextract($imm, 9)); }

LDTRSBW A64 00 111000 11 0 imm:9 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(1); reg_plus_imm($rn, sextract($imm, 9)); }

STTRH A64 01 111000 00 0 imm:9 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(2); reg_plus_imm($rn, sextract($imm, 9)); }

LDTRH A64 01 111000 01 0 imm:9 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(2); reg_plus_imm($rn, sextract($imm, 9)); }

LDTRSH A64 01 111000 10 0 imm:9 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(2); reg_plus_imm($rn, sextract($imm, 9)); }

LDTRSHW A64 01 111000 11 0 imm:9 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(2); reg_plus_imm($rn, sextract($imm, 9)); }

STTRW A64 10 111000 00 0 imm:9 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(4); reg_plus_imm($rn, sextract($imm, 9)); }

LDTRW A64 10 111000 01 0 imm:9 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(4); reg_plus_imm($rn, sextract($imm, 9)); }

LDTRSW A64 10 111000 10 0 imm:9 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(4); reg_plus_imm($rn, sextract($imm, 9)); }

STTR A64 11 111000 00 0 imm:9 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(8); reg_plus_imm($rn, sextract($imm, 9)); }

LDTR A64 11 111000 01 0 imm:9 10 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(8); reg_plus_imm($rn, sextract($imm, 9)); }

# C3.3.12 Load/store register (unscaled immediate)
# 31 30 29 28 27 26 25 24 23 22 21 20      12 11 10 9    5 4    0
#  size  1  1  1  V  0  0  opc   0    imm9     0  0   Rn     Rt
# NB: also includes C3.3.8 (immediate post-indexed)
# NB: also includes C3.3.9 (immediate pre-indexed)
# NB: 3.3.8 and 3.3.9 are merged using the idx field.
# NB: the address being accessed is the same with the exception
# NB: of post-indexed, where the address is not offset.
# NB: note that PRFUM has no pre/post version.
#  size           V        opc
#   00            0        00       STURB   -
#   00            0        01       LDURB   -
#   00            0        10       LDURSB  64-bit
#   00            0        11       LDURSB  32-bit
#   01            0        00       STURH   -
#   01            0        01       LDURH   -
#   01            0        10       LDURSH  64-bit
#   01            0        11       LDURSH  32-bit
#   10            0        00       STUR    32-bit
#   10            0        01       LDUR    32-bit
#   10            0        10       LDURSW  -
#   11            0        00       STUR    64-bit
#   11            0        01       LDUR    64-bit
#   11            0        10       PRFUM   -

STURB A64 00 111000 00 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $idx != 2; } \
!memory { align(1); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

LDURB A64 00 111000 01 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $idx != 2; } \
!memory { align(1); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

LDURSB A64 00 111000 10 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $idx != 2; } \
!memory { align(1); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

LDURSBW A64 00 111000 11 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $idx != 2; } \
!memory { align(1); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

STURH A64 01 111000 00 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $idx != 2; } \
!memory { align(2); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

LDURH A64 01 111000 01 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $idx != 2; } \
!memory { align(2); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

LDURSH A64 01 111000 10 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $idx != 2; } \
!memory { align(2); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

LDURSHW A64 01 111000 11 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $idx != 2; } \
!memory { align(2); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

STURW A64 10 111000 00 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $idx != 2; } \
!memory { align(4); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

LDURW A64 10 111000 01 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $idx != 2; } \
!memory { align(4); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

LDURSW A64 10 111000 10 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $idx != 2; } \
!memory { align(4); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

STUR A64 11 111000 00 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $idx != 2; } \
!memory { align(8); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

LDUR A64 11 111000 01 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $idx != 2; } \
!memory { align(8); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

PRFUM A64 11 111000 10 0 imm:9 00 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(8); reg_plus_imm($rn, sextract($imm, 9)); }

# C6.3.287 STUR (SIMD&FP)
# 31 30 29 28 27 26 25 24 23 22 21 20         12 11 10 9  5 4  0
#  size  1  1  1  1  0  0  x  0  0      imm9      0  0  Rn   Rt
#                [V]      [opc ]

STURB A64_V 00 111100 00 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $idx != 2; } \
!memory { align(1); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

LDURB A64_V 00 111100 01 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $idx != 2; } \
!memory { align(1); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

STURH A64_V 01 111100 00 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $idx != 2; } \
!memory { align(2); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

LDURH A64_V 01 111100 01 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $idx != 2; } \
!memory { align(2); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

STURS A64_V 10 111100 00 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $idx != 2; } \
!memory { align(4); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

LDURS A64_V 10 111100 01 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $idx != 2; } \
!memory { align(4); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

STURD A64_V 11 111100 00 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $idx != 2; } \
!memory { align(8); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

LDURD A64_V 11 111100 01 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $idx != 2; } \
!memory { align(8); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

STURQ A64_V 00 111100 10 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $idx != 2; } \
!memory { align(16); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

LDURQ A64_V 00 111100 11 0 imm:9 idx:2 rn:5 rt:5 \
!constraints { $rn != 31 && $idx != 2; } \
!memory { align(16); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 9)); }

# C3.3.13 Load/store register (unsigned immediate)
# 31 30 29 28 27 26 25 24 23 22 21         10 9    5 4    0
#  size  1  1  1  V  0  1  opc       imm12      Rn     Rt
#   00            0         00  STRB (immediate)
#   00            0         01  LDRB (immediate)
#   00            0         10  LDRSB (immediate)        64-bit
#   00            0         11  LDRSB (immediate)        32-bit
#   01            0         00  STRH (immediate)         Unsigned offset
#   01            0         01  LDRH (immediate)         Unsigned offset
#   01            0         10  LDRSH (immediate)        64-bit
#   01            0         11  LDRSH (immediate)        32-bit
#   10            0         00  STR (immediate)          32-bit
#   10            0         01  LDR (immediate)          32-bit
#   10            0         10  LDRSW (immediate)        Unsigned offset
#   11            0         00  STR (immediate)          64-bit
#   11            0         01  LDR (immediate)          64-bit
#   11            0         10  PRFM (immediate)         -

STRBi A64 00 111001 00 imm:12 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(1); reg_plus_imm($rn, $imm); }

LDRBi A64 00 111001 01 imm:12 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(1); reg_plus_imm($rn, $imm); }

LDRSBi A64 00 111001 10 imm:12 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(1); reg_plus_imm($rn, $imm); }

LDRSBWi A64 00 111001 11 imm:12 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(1); reg_plus_imm($rn, $imm); }

STRHi A64 01 111001 00 imm:12 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(2); reg_plus_imm($rn, $imm * 2); }

LDRHi A64 01 111001 01 imm:12 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(2); reg_plus_imm($rn, $imm * 2); }

LDRSHi A64 01 111001 10 imm:12 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(2); reg_plus_imm($rn, $imm * 2); }

LDRSHWi A64 01 111001 11 imm:12 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(2); reg_plus_imm($rn, $imm * 2); }

STRWi A64 10 111001 00 imm:12 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(4); reg_plus_imm($rn, $imm * 4); }

LDRWi A64 10 111001 01 imm:12 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(4); reg_plus_imm($rn, $imm * 4); }

LDRSWi A64 10 111001 10 imm:12 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(4); reg_plus_imm($rn, $imm * 4); }

STRi A64 11 111001 00 imm:12 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(8); reg_plus_imm($rn, $imm * 8); }

LDRi A64 11 111001 01 imm:12 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(8); reg_plus_imm($rn, $imm * 8); }

PRFMi A64 11 111001 10 imm:12 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt; } \
!memory { align(8); reg_plus_imm($rn, $imm * 8); }

# C6.3.285 STR (immediate, SIMD&FP) - Unsigned offset
#  31 30 29 28 27 26 25 24 23 22 21       10 9  5 4  0
#   size  1  1  1  1  0  1  opc     imm12     Rn   Rt
#                 [V]

STRBi A64_V 00 111101 00 imm:12 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1); reg_plus_imm($rn, $imm); }

LDRBi A64_V 00 111101 01 imm:12 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(1); reg_plus_imm($rn, $imm); }

STRHi A64_V 01 111101 00 imm:12 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(2); reg_plus_imm($rn, $imm * 2); }

LDRHi A64_V 01 111101 01 imm:12 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(2); reg_plus_imm($rn, $imm * 2); }

STRSi A64_V 10 111101 00 imm:12 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(4); reg_plus_imm($rn, $imm * 4); }

LDRSi A64_V 10 111101 01 imm:12 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(4); reg_plus_imm($rn, $imm * 4); }

STRDi A64_V 11 111101 00 imm:12 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(8); reg_plus_imm($rn, $imm * 8); }

LDRDi A64_V 11 111101 01 imm:12 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(8); reg_plus_imm($rn, $imm * 8); }

STRQi A64_V 00 111101 10 imm:12 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(16); reg_plus_imm($rn, $imm * 16); }

LDRQi A64_V 00 111101 11 imm:12 rn:5 rt:5 \
!constraints { $rn != 31; } \
!memory { align(16); reg_plus_imm($rn, $imm * 16); }

# C3.3.14 Load/store register pair (offset)
# 31 30 29 28 27 26 25 24 23 22 21      15 14     10 9    5 4    0
#  opc   1  0  1  V  0  1  0  L    imm7       Rt2      Rn     Rt
#   00            0           0    STP   32-bit
#   00            0           1    LDP   32-bit
#   01            0           1    LDPSW Signed offset
#   10            0           0    STP   64-bit
#   10            0           1    LDP   64-bit
# NB: also includes C3.3.15 (post-indexed)
# NB: also includes C3.3.16 (pre-indexed)
# NB: 3.3.15 and 3.3.16 are merged using the idx field.
# NB: the address being accessed is the same with the exception
# NB: of post-indexed, where the address is not offset.
# NB: note that idx=0 is not included (used for non-temporal pair)

STPW A64 00 101 0 0 idx:2 0 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rn != $rtt && $idx != 0; } \
!memory { align(8); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 7) * 4); }

LDPW A64 00 101 0 0 idx:2 1 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt && $rn != $rt && $rn != $rtt && $idx != 0; } \
!memory { align(8); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 7) * 4); }

LDPSW A64 01 101 0 0 idx:2 1 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt && $rn != $rt && $rn != $rtt && $idx != 0; } \
!memory { align(8); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 7) * 4); }

STP A64 10 101 0 0 idx:2 0 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rn != $rt && $rn != $rtt && $idx != 0; } \
!memory { align(16); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 7) * 8); }

LDP A64 10 101 0 0 idx:2 1 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt && $rn != $rt && $rn != $rtt && $idx != 0; } \
!memory { align(16); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 7) * 8); }

# C6.3.284 STP (SIMD&FP) post/pre signed offset
# 31 30 29 28 27 26 25 24 23 22 21    15 14   10 9  5 4  0
#  opc   1  0  1  1  0  0  1  0   imm7     Rt2    Rn   Rt
#                [V]   [idx ][L]
STPS A64_V 00 10110 idx:2 0 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $idx != 0; } \
!memory { align(8); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 7) * 4); }

LDPS A64_V 00 10110 idx:2 1 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt && $idx != 0; } \
!memory { align(8); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 7) * 4); }

STPD A64_V 01 10110 idx:2 0 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $idx != 0; } \
!memory { align(16); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 7) * 8); }

LDPD A64_V 01 10110 idx:2 1 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt && $idx != 0; } \
!memory { align(16); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 7) * 8); }

STPQ A64_V 10 10110 idx:2 0 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $idx != 0; } \
!memory { align(32); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 7) * 16); }

LDPQ A64_V 10 10110 idx:2 1 imm:7 rtt:5 rn:5 rt:5 \
!constraints { $rn != 31 && $rt != $rtt && $idx != 0; } \
!memory { align(32); reg_plus_imm($rn, $idx == 1 ? 0 : sextract($imm, 7) * 16); }


# - - - 1 0 0 - - - - - - - - - - - - - - - - Data processing - immediate
# C3.4.1 Add/subtract (immediate)
# 31 30 29 | 28 27 26 25 24 |23 22| 21       10 | 9    5 | 4    0
# sf op  S |  1  0  0  0  1 | shft|    imm12    |   Rn   |   Rd

ADDi A64 sf:1 00 10001 0 shft:1 imm:12 rn:5 rd:5 \
!constraints { $rn != 31 && $rd != 31; }

ADDSi A64 sf:1 01 10001 0 shft:1 imm:12 rn:5 rd:5 \
!constraints { $rn != 31 && $rd != 31; }

SUBi A64 sf:1 10 10001 0 shft:1 imm:12 rn:5 rd:5 \
!constraints { $rn != 31 && $rd != 31; }

SUBSi A64 sf:1 11 10001 0 shft:1 imm:12 rn:5 rd:5 \
!constraints { $rn != 31 && $rd != 31; }

# C3.4.2 Bitfield
# 31 | 30 29 | 28 27 26 25 24 23| 22 | 21      16 15      10 9    5 4    0
# sf |  opc  |  1  0  0  1  1  0|  N |    immr       imms      Rn     Rd
#
SBFM A64 sf:1 00 100110 sn:1 immr:6 imms:6 rn:5 rd:5 \
!constraints { \
    ($sf == $sn) && ($sf == 1 || ($immr <= 0x1f && $imms <= 0x1f)); \
}

BFM A64 sf:1 01 100110 sn:1 immr:6 imms:6 rn:5 rd:5 \
!constraints { \
    ($sf == $sn) && ($sf == 1 || ($immr <= 0x1f && $imms <= 0x1f)); \
}

UBFM A64 sf:1 10 100110 sn:1 immr:6 imms:6 rn:5 rd:5 \
!constraints { \
    ($sf == $sn) && ($sf == 1 || ($immr <= 0x1f && $imms <= 0x1f)); \
}

# C3.4.3 Extract
# 31 |30 29| 28 27 26 25 24 23| 22 | 21 | 20    16 15      10 9    5 4    0
# sf |op21 |  1  0  0  1  1  1|  N | o0 |    Rm       imms      Rn     Rd

EXTRW A64 0 00 100111 0 0 rm:5 0 imms:5 rn:5 rd:5

EXTR A64 1 00 100111 1 0 rm:5 imms:6 rn:5 rd:5

# C3.4.4 Logical (immediate)
# 31 |30 29| 28 27 26 25 24 23| 22 | 21      16 15      10 9    5 4    0
# sf |opc  |  1  0  0  1  0  0|  N |    immr       imms      Rn     Rd

ANDi A64 sf:1 00 100100 sn:1 immr:6 imms:6 rn:5 rd:5 \
!constraints { \
    ($rn != 31 && $rd != 31) && \
    (($sf == 0 && $sn == 0 && $imms < 0x1f) || \
     ($sf == 1 && $sn == 1 && $imms < 0x3f)); \
}

ORRi A64 sf:1 01 100100 sn:1 immr:6 imms:6 rn:5 rd:5 \
!constraints { \
    ($rn != 31 && $rd != 31) && \
    (($sf == 0 && $sn == 0 && $imms < 0x1f) || \
     ($sf == 1 && $sn == 1 && $imms < 0x3f)); \
}

EORi A64 sf:1 10 100100 sn:1 immr:6 imms:6 rn:5 rd:5 \
!constraints { \
    ($rn != 31 && $rd != 31) && \
    (($sf == 0 && $sn == 0 && $imms < 0x1f) || \
     ($sf == 1 && $sn == 1 && $imms < 0x3f)); \
}

ANDSi A64 sf:1 11 100100 sn:1 immr:6 imms:6 rn:5 rd:5 \
!constraints { \
    ($rn != 31 && $rd != 31) && \
    (($sf == 0 && $sn == 0 && $imms < 0x1f) || \
     ($sf == 1 && $sn == 1 && $imms < 0x3f)); \
}

# C3.4.5 Move wide (immediate)
# 31 |30 29| 28 27 26 25 24 23 | 22 21 | 20       5 4    0
# sf |opc  |  1  0  0  1  0  1 |  hw   |    imm16     Rd

MOVN A64 sf:1 00 100101 00 imm:16 rd:5

MOVZ A64 sf:1 10 100101 00 imm:16 rd:5

MOVK A64 sf:1 11 100101 00 imm:16 rd:5

# C3.4.6 PC-rel. addressing NIY

# - - - - 1 0 1 - - - - - - - - - - - - - - - Data processing - register

# C3.5.1 Add/subtract (extended register)
# 31 30 29 28 27 26 25 24 |23 22| 21 | 20    16 15    13 12  10 9    5 4    0
# sf op  S  0  1  0  1  1 | opt |  1 |    Rm     option   imm3    Rn     Rd

ADDx A64 sf:1 00 01011 00 1 rm:5 option:3 imm:3 rn:5 rd:5 \
!constraints { $rn != 31 && $rd != 31 && $imm <= 4; }

ADDSx A64 sf:1 01 01011 00 1 rm:5 option:3 imm:3 rn:5 rd:5 \
!constraints { $rn != 31 && $rd != 31 && $imm <= 4; }

SUBx A64 sf:1 10 01011 00 1 rm:5 option:3 imm:3 rn:5 rd:5 \
!constraints { $rn != 31 && $rd != 31 && $imm <= 4; }

SUBSx A64 sf:1 11 01011 00 1 rm:5 option:3 imm:3 rn:5 rd:5 \
!constraints { $rn != 31 && $rd != 31 && $imm <= 4; }

# C3.5.2 Add/subtract (shifted register)
# 31 30 29 28 27 26 25 24 |23 22| 21 | 20    16 15      10 9    5 4    0
# sf op  S  0  1  0  1  1 |shift|  0 |    Rm       imm6      Rn     Rd

ADD A64 sf:1 00 01011 shft:2 0 rm:5 imm:6 rn:5 rd:5 \
!constraints { $shft < 3 && ($sf == 1 || $imm <= 0x1f); }

ADDS A64 sf:1 01 01011 shft:2 0 rm:5 imm:6 rn:5 rd:5 \
!constraints { $shft < 3 && ($sf == 1 || $imm <= 0x1f); }

SUB A64 sf:1 10 01011 shft:2 0 rm:5 imm:6 rn:5 rd:5 \
!constraints { $shft < 3 && ($sf == 1 || $imm <= 0x1f); }

SUBS A64 sf:1 11 01011 shft:2 0 rm:5 imm:6 rn:5 rd:5 \
!constraints { $shft < 3 && ($sf == 1 || $imm <= 0x1f); }

# C3.5.3 Add/subtract (with carry)
# 31 30 29 28 27 26 25 24 23 22 21 |20    16 15         10 9    5 4    0
# sf op  S  1  1  0  1  0  0  0  0 |   Rm       opcode2      Rn     Rd

ADC A64 sf:1 00 11010000 rm:5 000000 rn:5 rd:5
ADCS A64 sf:1 01 11010000 rm:5 000000 rn:5 rd:5

SBC A64 sf:1 10 11010000 rm:5 000000 rn:5 rd:5
SBCS A64 sf:1 11 11010000 rm:5 000000 rn:5 rd:5

# C3.5.4 Conditional compare (immediate)

# 31 30 29 28 27 26 25 24 23 22 21 20      16 15      12 11 10 9    5 4 3      0
# sf op  1  1  1  0  1  0  0  1  0    imm5       cond     1  0   Rn   0   nzcv
#
#  0  0     CCMN (immediate) 32-bit
#  0  1     CCMP (immediate) 32-bit
#  1  0     CCMN (immediate) 64-bit
#  1  1     CCMP (immediate) 64-bit

CCMNi A64 sf:1 0 111010010 imm:5 cond:4 10 rn:5 0 nzcv:4
CCMPi A64 sf:1 1 111010010 imm:5 cond:4 10 rn:5 0 nzcv:4

# C3.5.5 Conditional compare (register)
# 31 30 29 28 27 26 25 24 23 22 21 20       16 15      12 11 10 9    5 4 3        0
# sf op  1  1  1  0  1  0  0  1  0      Rm        cond     0  0   Rn   0    nzcv
#  0  0     CCMN (register) 32-bit
#  0  1     CCMP (register) 32-bit
#  1  0     CCMN (register) 64-bit
#  1  1     CCMP (register) 64-bit

CCMN A64 sf:1 0 111010010 rm:5 cond:4 00 rn:5 0 nzcv:4
CCMP A64 sf:1 1 111010010 rm:5 cond:4 00 rn:5 0 nzcv:4

# C3.5.6 Conditional select
# 31 30 29 28 27 26 25 24 23 22 21 |20    16 15      12 11 10 9    5 4    0
# sf op  S  1  1  0  1  0  1  0  0 |   Rm       cond     op2    Rn     Rd

CSEL A64 sf:1 00 11010100 rm:5 cond:4 00 rn:5 rd:5
CSINC A64 sf:1 00 11010100 rm:5 cond:4 01 rn:5 rd:5
CSINV A64 sf:1 10 11010100 rm:5 cond:4 00 rn:5 rd:5
CSNEG A64 sf:1 10 11010100 rm:5 cond:4 01 rn:5 rd:5

# C3.5.7 Data-processing (1 source)
# 31 30 29 28 27 26 25 24 23 22 21 |20         16 15        10 9    5 4    0
# sf  1  S  1  1  0  1  0  1  1  0 |   opcode2       opcode      Rn     Rd

RBIT A64 sf:1 10 11010110 00000 000000 rn:5 rd:5
REV16 A64 sf:1 10 11010110 00000 000001 rn:5 rd:5
REV32 A64 sf:1 10 11010110 00000 000010 rn:5 rd:5
CLZ A64 sf:1 10 11010110 00000 000100 rn:5 rd:5
CLS A64 sf:1 10 11010110 00000 000101 rn:5 rd:5
REV A64 1 10 11010110 00000 000011 rn:5 rd:5

# C3.5.8 Data-processing (2 source)
# 31 30 29 28 27 26 25 24 23 22 21 |20    16 15        10 9    5 4    0
# sf  0  S  1  1  0  1  0  1  1  0 |   Rm       opcode      Rn     Rd

UDIV A64 sf:1 00 11010110 rm:5 000010 rn:5 rd:5
SDIV A64 sf:1 00 11010110 rm:5 000011 rn:5 rd:5
LSLV A64 sf:1 00 11010110 rm:5 001000 rn:5 rd:5
LSRV A64 sf:1 00 11010110 rm:5 001001 rn:5 rd:5
ASRV A64 sf:1 00 11010110 rm:5 001010 rn:5 rd:5
RORV A64 sf:1 00 11010110 rm:5 001011 rn:5 rd:5

# CRC32 availability is implementation-defined, commented out for now
#CRC32B A64 0 00 11010110 rm:5 010000 rn:5 rd:5
#CRC32H A64 0 00 11010110 rm:5 010001 rn:5 rd:5
#CRC32W A64 0 00 11010110 rm:5 010010 rn:5 rd:5
#CRC32CB A64 0 00 11010110 rm:5 010100 rn:5 rd:5
#CRC32CH A64 0 00 11010110 rm:5 010101 rn:5 rd:5
#CRC32CW A64 0 00 11010110 rm:5 010110 rn:5 rd:5
#CRC32X A64 1 00 11010110 rm:5 010011 rn:5 rd:5
#CRC32CX A64 1 00 11010110 rm:5 010111 rn:5 rd:5

# C3.5.9 Data-processing (3 source)
# 31 |30 29| 28 27 26 25 24 |23    21|20    16 15 14    10 9    5 4    0
# sf | op54|  1  1  0  1  1 |  op31  |   Rm    o0    Ra      Rn     Rd

MADD A64 sf:1 00 11011 000 rm:5 0 ra:5 rn:5 rd:5 \
!constraints { $ra != 31; }

MUL A64 sf:1 00 11011 000 rm:5 0 11111 rn:5 rd:5

MSUB A64 sf:1 00 11011 000 rm:5 1 ra:5 rn:5 rd:5 \
!constraints { $ra != 31; }

MNEG A64 sf:1 00 11011 000 rm:5 1 11111 rn:5 rd:5

SMADDL A64 1 00 11011 001 rm:5 0 ra:5 rn:5 rd:5 \
!constraints { $ra != 31; }

SMULL A64 1 00 11011 001 rm:5 0 11111 rn:5 rd:5

SMSUBL A64 1 00 11011 001 rm:5 1 ra:5 rn:5 rd:5 \
!constraints { $ra != 31; }

SMNEGL A64 1 00 11011 001 rm:5 1 11111 rn:5 rd:5

SMULH A64 1 00 11011 010 rm:5 0 ra:5 rn:5 rd:5

UMADDL A64 1 00 11011 101 rm:5 0 ra:5 rn:5 rd:5 \
!constraints { $ra != 31; }

UMULL A64 1 00 11011 101 rm:5 0 11111 rn:5 rd:5

UMSUBL A64 1 00 11011 101 rm:5 1 ra:5 rn:5 rd:5 \
!constraints { $ra != 31; }

UMNEGL A64 1 00 11011 101 rm:5 1 11111 rn:5 rd:5

UMULH A64 1 00 11011 110 rm:5 0 ra:5 rn:5 rd:5

# C3.5.10 Logical (shifted register)
# 31|30 29| 28 27 26 25 24 |23 22| 21| 20    16 15      10 9    5 4    0
# sf| opc |  0  1  0  1  0 |shift|  N|    Rm       imm6      Rn     Rd

AND A64 sf:1 00 01010 shft:2 0 rm:5 imm:6 rn:5 rd:5 \
!constraints { $sf == 1 || $imm <= 0x1f; }

BIC A64 sf:1 00 01010 shft:2 1 rm:5 imm:6 rn:5 rd:5 \
!constraints { $sf == 1 || $imm <= 0x1f; }

ORR A64 sf:1 01 01010 shft:2 0 rm:5 imm:6 rn:5 rd:5 \
!constraints { $sf == 1 || $imm <= 0x1f; }

ORN A64 sf:1 01 01010 shft:2 1 rm:5 imm:6 rn:5 rd:5 \
!constraints { $rn != 31 && ($sf == 1 || $imm <= 0x1f); }

MVN A64 sf:1 01 01010 shft:2 1 rm:5 imm:6 11111 rd:5 \
!constraints { $sf == 1 || $imm <= 0x1f; }

EOR A64 sf:1 10 01010 shft:2 0 rm:5 imm:6 rn:5 rd:5 \
!constraints { $sf == 1 || $imm <= 0x1f; }

EON A64 sf:1 10 01010 shft:2 1 rm:5 imm:6 rn:5 rd:5 \
!constraints { $sf == 1 || $imm <= 0x1f; }

ANDS A64 sf:1 11 01010 shft:2 0 rm:5 imm:6 rn:5 rd:5 \
!constraints { $sf == 1 || $imm <= 0x1f; }

BICS A64 sf:1 11 01010 shft:2 1 rm:5 imm:6 rn:5 rd:5 \
!constraints { $sf == 1 || $imm <= 0x1f; }

# C3.6 Data processing - SIMD and floating point (TODO)
# NIY
